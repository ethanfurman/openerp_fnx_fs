#!/usr/local/bin/suid-python
from __future__ import print_function

### BEGIN INIT INFO
# Provides: fnxfsd_init
# Required-Start: $remote_fs $syslog
# Required-Stop: $remote_fs $syslog
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Short-Description: fnxfs filesystem daemon
# Description: fnxfs filesystem daemon
### END INIT INFO

# this must happen first!
from pandaemonium import Daemon, FileTracker, PidLockFile, LockError, AlreadyLocked
from antipathy import Path
import logging
from logging import FileHandler


###############################################################################
#
# Notes:
#
#   There is an issue with reading symbolic links from a reflected directory
#
#   For now, do not read links
#
#
###############################################################################

DEFAULT_LOG = Path('/var/log/fnxfsd.log')

FileTracker.install()

# this must happen second!
import sys
PYTHON_TARGET = 'python%s.%s' % sys.version_info[:2]
try:
    sys.path.remove('/usr/local/lib/%s/dist-packages' % PYTHON_TARGET)
except ValueError:
    pass
sys.path.insert(0, '/usr/local/lib/%s/dist-packages' % PYTHON_TARGET)

# okay

import Crypto
import operator as op
import os
import scription
import SocketServer
import syslog
import threading
import traceback

from collections import defaultdict
from dbf import DateTime
from errno import *
from grp import getgrall as get_all_groups
from pwd import getpwuid, getpwnam as get_pw_entry
from scandir import scandir
from scription import *
from socket import socket, AF_INET, SOCK_STREAM
from stat import S_ISDIR as is_dir, S_ISLNK as is_link, ST_MODE, ST_UID, ST_GID
from threading import RLock
from time import time, sleep
from VSS.paramiko import SSHClient
from VSS.paramiko.client import AutoAddPolicy
from VSS.paramiko.ssh_exception import SSHException
from VSS.utils import get_local_ip
from VSS.xfuse import FUSE, FuseOSError, ENOTSUP
from VSS.xfuse import fuse_get_context as fuse_context

VERSION = '1.1.beta7'

HOME = Path('/home')
SHADOW = Path('/home/.shadow')
FNXFS_SHADOW = Path('/home/.fnxfs_shadow')
TARGET = None
MOUNT_FILE = Path('/etc/openerp/fnxfs.mount')
PID_FILE = Path('/var/run/fnxfsd.pid')
REMOTE_ROOT = Path('/var/openerp/fnxfs/')
TCP_PORT = 8068

DATA_LOCK = RLock()
COMM_LOCK = RLock()
CONTEXT = threading.local()  # used for thread-local storage
AS_ROOT = False
AS_USER = getpwuid(os.getuid()).pw_name
if AS_USER == 'root':
    AS_ROOT = True
    AS_USER = None

os.environ['PATH'] = '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'
os.environ['HOME'] = '/root'

if Path.exists('/run'):
    PIDFILE = Path('/run/fnxfsd.pid')
else:
    PIDFILE = Path('/var/run/fnxfsd.pid')


@Script()
def main():
    syslog.syslog(' '.join([repr(a) for a in sys.argv]))
    if os.getuid() == 0:
        print('running as root')
        syslog.syslog('running as root')
    else:
        syslog.syslog('running as user')
        # only allow user functions
        if module.script_command_name not in (
                'create-file', 'delete-file', 'change-file',
                'create-folder', 'delete-folder', 'change-folder',
                ):
            syslog.syslog('must be root to run %r' % module.script_command_name)
            abort('must be root to run %r' % module.script_command_name)
        print('running as', module.AS_USER)


#------------------------
# daemon control commands
#------------------------

@Command(timeout=('time to wait for daemon to start', OPTION, 't', int), )
def restart(timeout=10):
    'stop and start the FnxFS system'
    try:
        _stop()
    except SystemExit, exc:
        pass
        # if exc.code != 32 and 'not mounted' not in:
        #     # 32 -> not mounted
        #     raise
    _start(timeout)


@Command(timeout=('time to wait for daemon to start', OPTION, 't', int), )
def start(timeout=10):
    'Start the FnxFS system'
    print('timeout is %r <%s>' % (timeout, type(timeout)))
    _start(timeout)


@Command()
def stop():
    'Stop the FnxFS system'
    _stop()


#---------------------------
# FnxFS interaction commands
#---------------------------

@Command()
def change_file():
    pass


@Command(
        src=Spec('/path/to/filename', type=Path, abbrev=None),
        dst=Spec('folder[/folder[/...]][/share_as_filename]', type=Path, abbrev=None),
        styp=Spec('share type', OPTION, choices=['live', 'publish', 'auto-publish'], abbrev=None, default='live'),
        ptyp=Spec('permission type', OPTION, choices=['custom', 'inherit'], abbrev=None, default='inherit'),
        ro_users=Spec('users with read-only access', MULTI, abbrev=None),
        rw_users=Spec('users with read-write access [only for "live" files]', MULTI, abbrev=None),
        desc=Spec('short description of file', OPTION, abbrev=None, default=''),
        freq=Spec('how often to republish file [only for "auto-publish" files]', OPTION, abbrev=None, default=''),
        user=Spec('run this command as USER', OPTION, abbrev=None, default=AS_USER),
        config=Spec('location of configuration file', OPTION, abbrev=None, default=Path('/usr/local/etc/fnxfs_credentials')),
        )
def create_file(src, dst, styp, ptyp, ro_users, rw_users, desc, freq, user, config):
    "create a virtual file"
    execfile(config, globals())
    if user != AS_USER and not AS_ROOT:
        abort('must be root to specify a different USER')
    elif user is None:
        abort('USER must be specified when running as root')
    if not src.startswith(('/home/%s/' % AS_USER, '/home/.shadow/%s/' % AS_USER, '/home/.fnxfs_shadow/%s/' % AS_USER)):
        abort("can only share files from USER's home directory")
    params = ['client:'+src, dst, '--styp=%s' % styp, '--ptyp=%s' % ptyp]
    if ro_users:
        params.append('--ro-users=%s' % ','.join(ro_users))
    if rw_users:
        params.append('--rw-users=%s' % ','.join(rw_users))
    if user not in ro_users + rw_users:
        rw_users.append(user)
    if desc:
        params.append('--desc="%s"' % desc.replace('"', '\\"'))
    if freq:
        params.append('--freq="%s"' % freq)
    if script_verbose:
        params.append('-' + 'v'*script_verbose)
    attempt = Execute(['ssh', openerp, '/usr/local/bin/fnxfs', 'create-file'] + params)
    if attempt.stdout:
        print(attempt.stdout, verbose=0)
    if attempt.stderr:
        print(attempt.stderr, file=stderr)
    if attempt.returncode or attempt.stderr:
        raise SystemExit(attempt.returncode or 1)


@Command(
        name=Spec('name of new folder', type=Path, abbrev=None),
        styp=Spec('share type', OPTION, choices=['mirror', 'share', 'virtual'], abbrev=None, default='virtual'),
        ptyp=Spec('permission type', OPTION, choices=['custom', 'inherit'], abbrev=None, default='inherit'),
        ro_users=Spec('users with read-only access', MULTI, abbrev=None),
        rw_users=Spec('users with read-write access [only for "virtual" folders', MULTI, abbrev=None),
        cd_users=Spec('users with create/delete access [only for "virtual" folders]', MULTI, abbrev=None),
        desc=Spec('short description of folder', OPTION, abbrev=None, default=''),
        user=Spec('run this command as USER', OPTION, abbrev=None, default=AS_USER),
        config=Spec('location of configuration file', OPTION, abbrev=None, default=Path('/usr/local/etc/fnxfs_credentials')),
        )
def create_folder(name, styp, ptyp, ro_users, rw_users, cd_users, desc):
    "create a new folder, specifying share and permission types, user access, and description"
    execfile(config, globals())
    if user != AS_USER and not AS_ROOT:
        abort('must be root to specify a different USER')
    params = [name, '--styp=%s' % styp, '--ptyp=%s' % ptyp]
    if ro_users:
        params.append('--ro-users=%s' % ','.join(ro_users))
    if rw_users:
        params.append('--rw-users=%s' % ','.join(rw_users))
    if cd_users:
        params.append('--cd-users=%s' % ','.join(cd_users))
    if user not in ro_users + rw_users + cd_users:
        cd_users.append(user)
    if desc:
        params.append('--desc="%s"' % desc.replace('"', '\\"'))
    if script_verbose:
        params.append('-' + 'v'*script_verbose)
    attempt = Execute(['ssh', openerp, '/usr/local/bin/fnxfs', 'create-folder'] + params)
    if attempt.stdout:
        print(attempt.stdout, verbose=0)
    if attempt.stderr:
        print(attempt.stderr, file=stderr)
    if attempt.returncode or attempt.stderr:
        raise SystemExit(attempt.returncode or 1)


@Command()
def change_folder():
    pass


@Command(
        name=('path/name of file to remove', ),
        )
def delete_file(name, user):
    "remove a folder from FnxFS"
    params = [name]
    if AS_USER is not None:
        params.append('--user=%s' % AS_USER)
    if script_verbose:
        params.append('-' + 'v'*script_verbose)
    attempt = Execute(['ssh', openerp, '/usr/local/bin/fnxfs', 'delete-file'] + params)
    if attempt.stdout:
        print(attempt.stdout, verbose=0)
    if attempt.stderr:
        print(attempt.stderr, file=stderr)
    if attempt.returncode or attempt.stderr:
        raise SystemExit(attempt.returncode or 1)


@Command(
        name=('path/name of file to remove', ),
        )
def delete_file(name, user):
    "remove a file from FnxFS"
    params = [name]
    if AS_USER is not None:
        params.append('--user=%s' % AS_USER)
    if script_verbose:
        params.append('-' + 'v'*script_verbose)
    attempt = Execute(['ssh', openerp, '/usr/local/bin/fnxfs', 'delete-folder'] + params)
    if attempt.stdout:
        print(attempt.stdout, verbose=0)
    if attempt.stderr:
        print(attempt.stderr, file=stderr)
    if attempt.returncode or attempt.stderr:
        raise SystemExit(attempt.returncode or 1)


@Command(
        name=Spec('name of file/folder/user to show', default=''),
        all_users=Spec('list all users', FLAG),
        )
def show(name, all_users):
    "display information about a user/file/folder"
    params = [name]
    if all_users:
        params.append('--all-users')
    if script_verbose:
        params.append('-' + 'v'*script_verbose)
    attempt = Execute(['ssh', openerp, '/usr/local/bin/fnxfs', 'show'] + params)
    if attempt.stdout:
        print(attempt.stdout, verbose=0)
    if attempt.stderr:
        print(attempt.stderr, file=stderr)
    if attempt.returncode or attempt.stderr:
        raise SystemExit(attempt.returncode or 1)


@Command(
        path=Spec('path to examine', REQUIRED, default=Path('/')),
        include_files=Spec('display files', FLAG, 'f'),
        )
def tree(path, include_files, _prefix='', _files=defaultdict(list), _pool={}):
    "display a tree of the folder/file structure in FnxFS"
    params = [path]
    if include_files:
        params.append('--include-files')
    if script_verbose:
        params.append('-' + 'v'*script_verbose)
    attempt = Execute(['ssh', openerp, '/usr/local/bin/fnxfs', 'show'] + params)
    if attempt.stdout:
        print(attempt.stdout, verbose=0)
    if attempt.stderr:
        print(attempt.stderr, file=stderr)
    if attempt.returncode or attempt.stderr:
        raise SystemExit(attempt.returncode or 1)


#----------------
# fnxfsd commands
#----------------

@Command(
        user=('user to check on', ),
        config=('location of configuration file', OPTION, 'c', Path),
        )
def dump_permissions(
        user,
        config='/usr/local/etc/fnxfs_credentials',
        ):
    """
    Query the running daemon for the cache of the requested user.
    """
    execfile(config, globals())
    user = user.encode('utf8')
    server_ip = get_local_ip(openerp)
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((server_ip, TCP_PORT))
    s.sendall('service:dump_permissions\nuser:%s' % (user, ))
    while True:
        data = s.recv(1024)
        if not data:
            break
        print(data, end='', verbose=0)
    s.close()
    print(verbose=0)


@Command(
        user=('user to check on', ),
        config=('location of configuration file', OPTION, 'c', Path),
        )
def dump_folders(
        user,
        config='/usr/local/etc/fnxfs_credentials',
        ):
    """
    Query the running daemon for the cache of the requested user.
    """
    execfile(config, globals())
    user = user.encode('utf8')
    server_ip = get_local_ip(openerp)
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((server_ip, TCP_PORT))
    s.sendall('service:dump_folders\nuser:%s' % (user, ))
    while True:
        data = s.recv(1024)
        if not data:
            break
        print(data, end='', verbose=0)
    s.close()
    print(verbose=0)


@Command(
        user=('user to check on', ),
        config=('location of configuration file', OPTION, 'c', Path),
        )
def dump_cache(
        user,
        config='/usr/local/etc/fnxfs_credentials',
        ):
    """
    Query the running daemon for the cache of the requested user.
    """
    execfile(config, globals())
    user = user.encode('utf8')
    server_ip = get_local_ip(openerp)
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((server_ip, TCP_PORT))
    s.sendall('service:dump_cache\nuser:%s' % (user, ))
    while True:
        data = s.recv(1024)
        if not data:
            break
        print(data, end='', verbose=0)
    s.close()
    print(verbose=0)


@Command(
        user=('user to check on', ),
        file_name=('file to look for', ),
        config=('location of configuration file', OPTION, 'c', Path),
        )
def find_path(
        user,
        file_name,
        config='/usr/local/etc/fnxfs_credentials',
        ):
    """
    Query the running daemon for the last path that had file_name in it.
    """
    execfile(config, globals())
    user = user.encode('utf8')
    file_name = file_name.encode('utf8')
    print('checking user %r for %r' % (user, file_name))
    server_ip = get_local_ip(openerp)
    s = socket(AF_INET, SOCK_STREAM)
    s.connect((server_ip, TCP_PORT))
    s.sendall('service:find_path\nuser:%s\nfile_name:%s' % (user, file_name))
    while True:
        data = s.recv(1024)
        if not data:
            break
        print(data, end='', verbose=0)
    s.close()
    print(verbose=0)

@Command(
        level=('new log level', REQUIRED, 'l', int),
        )
def log_level(
        level,
        ):
    s = socket(AF_INET, SOCK_STREAM)
    s.connect(('127.0.0.1', TCP_PORT))
    s.sendall('service:log_level\nlevel:%d' % (level, ))
    while True:
        data = s.recv(1024)
        if not data:
            break
        print(data, end='', verbose=0)
    s.close()
    print(verbose=0)


@Command(
        device=('path to mirror', REQUIRED, None, Path),
        mount=('where to put mirrored path', REQUIRED, None, Path),
        option=('file system options', MULTI),
        config=('location of configuration file', OPTION, None, Path),
        remote_root=('location on server to share as FnxFS', OPTION, None, Path),
        shares_file=('file on server with external shares', OPTION, None, Path),
        pid_file=('pid file for daemon', OPTION, None, Path),
        foreground=('remain in foreground', FLAG, 'f'),
        log=('additional (duplicate) log file', OPTION, None, Path),
        verbose=('extra detail in log', FLAG, 'v'),
        port=('port for mini-tcp server to use', OPTION, None, int),
        testing=('configure certain values to enable testing', FLAG),
        )
@Alias('mount.fnxfs')
def fnxfsd(
        device,
        mount,
        option,
        config='/usr/local/etc/fnxfs_credentials',
        remote_root=REMOTE_ROOT,
        shares_file=MOUNT_FILE,
        pid_file=PID_FILE,
        foreground=False,
        log='',
        verbose=False,
        port=8068,
        testing=False,
        ):

    device = Path(device.encode(scription.LOCALE_ENCODING))
    mount = Path(mount.encode(scription.LOCALE_ENCODING))
    remote_root = Path(remote_root.encode(scription.LOCALE_ENCODING))

    execfile(config, globals())

    pid_lock = PidLockFile(pid_file)
    try:
        pid_lock.acquire()
        with open('/var/log/start-fnxfsd', 'a') as l:
            l.write('%s --> %s  [acquired]\n' % (DateTime.now(), sys.argv))
    except AlreadyLocked:
        with open('/var/log/start-fnxfsd', 'a') as l:
            l.write('%s --> %s  [already running]\n' % (DateTime.now(), sys.argv))
        raise SystemExit('fnxfsd already running')
    except LockError:
        with open('/var/log/start-fnxfsd', 'a') as l:
            l.write('%s --> %s  [not able to acquire]\n' % (DateTime.now(), sys.argv))
        raise SystemExit('unable to acquire lock')
    global LOGGER, FH, CONSOLE, SERVER_DELAY, ARCHIVE_OKAY, TCP_PORT
    LOGGER = logging.getLogger()
    LOGGER.setLevel(logging.DEBUG)
    FH = FileHandler(
            filename=DEFAULT_LOG,
            encoding='utf8',
            )
    FH.setLevel(logging.WARNING)
    FH.setFormatter(logging.Formatter("%(thread)5d:  %(asctime)-30s %(name)-40s %(message)s"))
    LOGGER.addHandler(FH)
    LOGGER = logging.getLogger('fnxfsd')
    if foreground:
        CONSOLE = logging.StreamHandler()
        CONSOLE.setFormatter(logging.Formatter("%(message)s"))
        CONSOLE.setLevel(logging.INFO)
        LOGGER.addHandler(CONSOLE)
    if verbose:
        FH.setLevel(logging.DEBUG)
        if foreground:
            CONSOLE.setLevel(logging.DEBUG)
    TCP_PORT = port
    logging.warning('using port %d', port)
    if testing:
        SERVER_DELAY = 0
        ARCHIVE_OKAY = False
    else:
        SERVER_DELAY = 1
        ARCHIVE_OKAY = True
    LOGGER.info('~~~ config file: %s', config)
    read_write = True
    threads = False
    for opt in option:
        if opt == 'rw':
            read_write = True
        elif opt == 'ro':
            read_write = False
        elif opt == 'threads':
            threads = True
        elif opt == 'nothreads':
            threads = False
        elif opt == 'noauto':
            pass
        elif opt == '_netdev':
            pass
        else:
            raise ValueError('unknown option: %r' % opt)

    fuse_kwargs = dict(
            foreground=True,
            allow_other=True,
            atime=True,
            nonempty=True,
            entry_timeout=0.0,
            attr_timeout=0.0,
            nothreads=not threads,
            sync_read=True,     # assure multi-thread reads happen in order
            # hard_remove=True,
            #follow_symlinks=True,
            )
    LOGGER.debug('*** fuse args: %s', fuse_kwargs)

    if foreground:
        pid_lock.seal()
    else:
        daemon = Daemon()
        daemon.inherit_files = [ fn for fn in (
                FileTracker.active('/dev/urandom', None),
                FileTracker.active(DEFAULT_LOG, None),
                ) if fn is not None ]
        daemon.pid_file = pid_lock
        daemon.uid = 0
        daemon.gid = 0
        daemon.umask = 0
        if log:
            daemon.stdout = log
            daemon.stderr = log
        daemon.activate()
        Crypto.Random.atfork()

    ts = TcpServer()
    ts.start()
    FUSE(
        FnxFS(
            host=openerp, server_user=server_user, server_pass=server_pass, server_root=root,
            home=mount, local_device=device, remote_root=remote_root, read_write=read_write,
            shares_file=shares_file,
            ),
        mount,
        **fuse_kwargs)


@Command(
    init=('overwrites existing contents in shadow directory', FLAG),
    user=('only process specified user', OPTION),
    )
def sweep(init, user):
    'moves user data (non-dot files) into a mirrored location controlled by FnxFS'
    print('looking for candidates...', end='')
    _squat()
    possibles = [
        p
        for p in HOME.glob('*')
        if
           p.isdir() and
           p[0] != '.' and
           p not in ('lost+found', 'backup-media') and
           (user is None or p.filename == user)
        ]
    print(' found %d' % len(possibles))
    print('possibles:', possibles, verbose=2)
    for p in possibles:
        print('  checking %s...' % p)
        targets = [
            t
            for t in p.listdir()
            if
                t[0] != '.' and
                not p.islink(t) and
                (p.isdir(t) or p.isfile(t))
            ]
        print('targets:', targets, verbose=2)
        user = p.filename
        for t in targets:
            src = p/t
            new_home = TARGET / user
            dst = new_home / t
            print('    moving %s to %s' % (src, dst))
            if not new_home.exists():
                new_home.mkdir()
                stat = p.stat()
                new_home.chown(stat.st_uid, stat.st_gid)
                new_home.chmod(stat.st_mode)
            try:
                src.rename(dst)
            except OSError, exc:
                if exc.errno not in (EISDIR, ENOTEMPTY):
                    raise
                if not init:
                    abort('directory %s already exists; did you mean to use --init?' % dst)
                dst.rmtree()
                src.rename(dst)
            # *always* link to SHADOW
            (SHADOW/user/t).symlink(src)


@Command(
    user=('only process specified user', OPTION),
    )
def undo_sweep(user):
    'remove symbolic links and move user data back to /home/[user]/'
    # data to move back is in TARGET
    _squat()
    possibles = [
        p
        for p in TARGET.glob('*')
        if
           p.isdir() and
           p[0] != '.' and
           p not in ('lost+found', ) and
           (user is None or p.filename == user)
        ]
    print('possibles:', possibles, verbose=2)
    problems = []
    for p in possibles:
        targets = p.listdir()
        print('targets:', targets, verbose=2)
        user = p.filename
        for t in targets:
            src = p/t
            old_home = HOME / user
            dst = old_home / t
            if dst.exists():
                if not dst.islink():
                    problems.append(dst)
                    continue
                dst.unlink()
            print('moving %s to %s' % (src, dst))
            src.rename(dst)
    if problems:
        abort('unable to move the following files/directories:\n\t%s' % '\n\t'.join(problems))


class RequestHandler(SocketServer.BaseRequestHandler):
    """
    Answer requests for path of file.
    """

    timeout = 15
    file_cache = None   # injected when fnxfs starts up
    permissions = None
    folders = None

    def handle(self):
        LOGGER.info('handling: %s', self.client_address)
        request = self.request.recv(1024).strip().split('\n')
        LOGGER.info('request: %s', request)
        try:
            params = dict([line.split(':') for line in request])
            func = getattr(self, 'do_' + params.pop('service'))
        except (ValueError, KeyError):
            exc_type, exc, exc_tb = sys.exc_info()
            result = ''.join(traceback.format_exception(exc_type, exc, exc_tb))
            LOGGER.debug(result)
            self.request.sendall('error:EPROTO\n0\n' + result)
        else:
            try:
                LOGGER.debug(params)
                result = func(**params)
            except TypeError:
                exc_type, exc, exc_tb = sys.exc_info()
                result = ''.join(traceback.format_exception(exc_type, exc, exc_tb))
                LOGGER.debug(result)
                self.request.sendall('error:EPROTO\n1\n' + result)
            except Exception:
                exc_type, exc, exc_tb = sys.exc_info()
                result = ''.join(traceback.format_exception(exc_type, exc, exc_tb))
                LOGGER.debug(result)
                self.request.sendall('exception:\n' + result)
            else:
                LOGGER.info('result: %s', result)
                if result is None:
                    self.request.sendall('error:ENOENT')
                else:
                    self.request.sendall('result:\n%s' % (result, ))

    def do_find_path(self, user, file_name):
        LOGGER.warning('checking %r for %r', user, file_name)
        return self.file_cache.find(user, file_name)

    def do_dump_cache(self, user):
        LOGGER.warning('user: %r', user)
        result = []
        for path in reversed(self.file_cache.paths[user]):
            result.append(path)
            for file in self.file_cache.cache[user][path]:
                result.append('   %s' % file)
        LOGGER.warning('found %d items', len(result))
        return '\n'.join(result)

    def do_dump_folders(self, user):
        result = []
        for entry, files in self.folders[user].items():
            result.append('%s: %s' % (entry, files))
        return '\n'.join(result)

    def do_dump_permissions(self, user):
        result = []
        for entry, perm in self.permissions[user].items():
            result.append('%s: %o' % (entry, perm))
        return '\n'.join(result)

    def do_log_level(self, level):
        FH.setLevel(int(level))
        return self.client_address


class TcpServer(threading.Thread):
    """
    Serve requests for file paths.
    """

    daemon = True
    allow_reuse_address = True

    def run(self):
        LOGGER.info('starting tcp server')
        #server_ip = get_local_ip(openerp)
        while True:
            try:
                server = SocketServer.TCPServer(('', TCP_PORT), RequestHandler)
                server.serve_forever()
            except Exception:
                LOGGER.exception('error occured')
                sleep(45)


def _auto_success(*args, **kwds):
    return 0

def _no_access(*args, **kwds):
    raise OSError(EACCES, 'permission denied')

def _no_support(*args, **kwds):
    raise OSError(ENOTSUP, 'operation not supported')

def _is_hidden_or_swap(path):
    return path.filename.startswith('.') or path.filename.endswith('~')

def _is_lock_file(path, error=True):
    if not path.filename.startswith('.~lock.'):
        if error:
            raise OSError(EACCES, 'permission denied')
        return False
    return True

def _locked_file_from(lock_file):
    # currently supported lock file types:
    #   .~lock.file_name.ext#
    lfn = lock_file.base[7:]
    lfe = lock_file.ext[:4]
    return lock_file.path/lfn+lfe

def _get_groups_ids(user, uid, gid):
    gids = [g.gr_gid for g in get_all_groups() if user in g.gr_mem]
    gids.append(gid)
    return gids

def _get_lockfile(sftp, path):
    # looks to see if any lockfiles matching path exist on server
    template = path.path / '.~lock.' + path.filename
    listing = sftp.listdir(path.path)
    for name in listing:
        if name.startswith(template):
            return name

def check_rwx(file_stat, mode, context, global_read_write):
    grw_mask = (0o555, 0o777)[global_read_write]
    file_perm = file_stat[ST_MODE] & grw_mask
    sticky_dir = file_stat[ST_MODE] & 0o2000
    LOGGER.debug('--- perm %s (global read_write: %s)', oct(file_perm), global_read_write)
    LOGGER.debug('---       -uid-  -gid-')
    LOGGER.debug('--- file  %5d  %5d', file_stat[ST_UID], file_stat[ST_GID])
    LOGGER.debug('--- user  %5d  %5d', context.uid, context.gid)
    user, group, other = 0, 0, 0
    if context.uid == file_stat[ST_UID]:
        LOGGER.debug('*** checking owner')
        user = (file_perm & 0o700) >> 6
        LOGGER.debug('*** user -> %d', user)
        LOGGER.debug('*** user & mode -> %d', user & mode)
        # if user & mode == mode:
        #     return context.uid, context.gid, sticky_dir, file_stat[ST_GID]
    if context.gid == file_stat[ST_GID]:
        LOGGER.debug('*** checking group')
        group = (file_perm & 0o070) >> 3
        LOGGER.debug('*** group -> %d', group)
        LOGGER.debug('*** group & mode -> %d', group & mode)
        # if group & mode == mode:
        #     return context.uid, context.gid, sticky_dir, file_stat[ST_GID]
    # if context.uid != file_stat[ST_UID] and context.gid != file_stat[ST_GID]:
    LOGGER.debug('*** checking world')
    other = file_perm & 0o007
    LOGGER.debug('*** other -> %d', other)
    LOGGER.debug('*** other & mode -> %d', other & mode)
        # if other & mode == mode:
        #     return context.uid, context.gid, sticky_dir, file_stat[ST_GID]
    if (user | group | other) & mode == mode:
        return context.uid, context.gid, sticky_dir, file_stat[ST_GID]
    _no_access()

def non_ascii(path):
    "Only checks the last piece."
    for ch in path.filename:
        if ord(ch) > 127:
            return True

def possibly_archive(sftp, written_files, path):
    # if data was ever written to 'path', archive it now
    if path in written_files:
        written_files.remove(path)
        LOGGER.info('--- archiving %s', path)
        if ARCHIVE_OKAY:
            stdin, stdout, stderr = sftp.exec_command('/usr/local/bin/fnxfs archive "%s"' % path)
            data = []
            while True:
                text = stderr.read(1024)
                if not text:
                    break
                data.append(text)
            if data:
                for line in ''.join(data).split('\n'):
                    LOGGER.error(line.strip())


class FnxFS(object):
    """
    A simple SFTP filesystem. Requires paramiko:
            http://www.lag.net/paramiko/

    A file-system to be used with OpenERP FnxFS file system module.
    """
    def __init__(
            self,
            host, server_user, server_pass, server_root,
            home, local_device, remote_root, read_write,
            shares_file,
            ):
        self._host = host
        self._server_user = server_user
        self._server_pass = server_pass
        self._server_root = server_root
        self._client = SSHClient()
        self._client.load_system_host_keys()
        self._client.set_missing_host_key_policy(AutoAddPolicy())
        self._last_attempt = 0
        self._last_permissions_check = 0
        self._server = SSHClient()
        self._server.load_system_host_keys()
        self._server.set_missing_host_key_policy(AutoAddPolicy())
        self._connect()
        self._home = home
        self._local_root = local_device
        self._remote_root = remote_root
        self._permission_file = remote_root / '..' / 'fnxfs.permissions'
        self._read_write = read_write
        self._shares_file = shares_file
        self._active_users = set([])
        self._uid = 0
        self._gid = 0
        self._permission_state = None
        self._allowed_users = set()
        self._mount = set()
        self._cache = defaultdict(dict)
        self._file_permissions = defaultdict(dict)
        self._folders = defaultdict(dict)
        self._written = defaultdict(set)
        self.seen_files = Accessed()
        # self.rwlock = Lock()
        RequestHandler.file_cache = self.seen_files
        RequestHandler.permissions = self._file_permissions
        RequestHandler.folders = self._folders
  
    def _connect(self):
        now = time()
        if now - self._last_attempt < 90:
            return False
        self._last_attempt = now
        LOGGER.info('connecting as %s to %s', self._server_user, self._host)
        try:
            self._client.connect(self._host, username=self._server_user, password=self._server_pass, timeout=5)
        except Exception:
            exc = sys.exc_info()[1]
            LOGGER.exception('failed to connect with server')
            self._sftp = None
            return False
        else:
            self._sftp = self._client.open_sftp()
            return True

    def _server_connect(self):
        LOGGER.info('connecting as root to %s', self._host)
        try:
            self._server.connect(self._host, username='root', password=self._server_root, timeout=5)
        except Exception:
            exc = sys.exc_info()[1]
            LOGGER.exception('failed to connect with server')
            return False
        else:
            return True

    def __call__(self, op, path, *args):
        LOGGER.info('--> %s %s %s', op, path, repr(args)[:200])
        ret = '[unhandled exception]'
        flush = False
        uid, gid, pid = fuse_context()
        CONTEXT.uid = uid
        CONTEXT.gid = gid
        CONTEXT.pid = pid
        CONTEXT.user = user = getpwuid(uid).pw_name
        LOGGER.debug('=== CONTEXT: %r', CONTEXT)
        lock = None
        try:
            path = Path(path)
            if len(path) > 1024:
                LOGGER.warning('BIG PATH! (%d bytes) <%s>', len(path), path)
            CONTEXT.original_path = path
            if op not in ('init','destroy','statfs'):
                elements = path.elements
                if elements[2:3] == ['FnxFS']:
                    lock = COMM_LOCK
                    lock.acquire()
                    # check for valid connection
                    LOGGER.debug('grabbing DATA_LOCK')
                    with DATA_LOCK:
                        LOGGER.debug('data lock obtained')
                        if self._sftp is None:
                            if not self._connect():
                                raise OSError(ENOLINK, 'remote link down')
                        # save share uid/gid
                        LOGGER.debug('actual user: %r', user)
                        try:
                            entry = get_pw_entry(elements[1])
                        except KeyError:
                            # user has been removed from system?
                            self._check_permissions()
                            _no_access()
                        LOGGER.debug('effective user: %r', entry.pw_name)
                        CONTEXT.share_uid = entry.pw_uid
                        CONTEXT.share_gid = entry.pw_gid
                        # XXX: next two lines are suspicious
                        if CONTEXT.uid == 0:
                            CONTEXT.user = entry.pw_name
                        if CONTEXT.uid and CONTEXT.uid != CONTEXT.share_uid and len(elements) > 3:
                            _no_access()
                        path = '/'.join(path.elements[3:])
                        if path:
                            path = self._remote_root/path
                        else:
                            path = self._remote_root
                        op = 'remote_' + op
                else:
                    path = self._local_root/path
                    op = 'local_' + op
            LOGGER.debug('context ->  uid:%r, gid:%r, name:%r', CONTEXT.uid, CONTEXT.gid, CONTEXT.user)
            func = getattr(self, op)
            if func is None:
                raise OSError(EFAULT, 'bad operation')
            LOGGER.debug('--- %s', path)
            ret = func(path, *args)
            return ret
        except OSError:
            exc_type, exc, exc_tb = sys.exc_info()
            ret = str(exc)
            raise
        except Exception:
            exc_type, exc, exc_tb = sys.exc_info()
            ret = str(exc)
            flush = True
            LOGGER.exception('error occured')
            raise
        finally:
            if lock is not None:
                lock.release()
            LOGGER.info('<-- %s %s', op, repr(ret)[:200])
            LOGGER.info('')

    def __getattr__(self, name):
        """
        Return True if a local_ or remote_ version of `name` is found.
        """
        local = self.__class__.__dict__.get('local_'+name)
        remote = self.__class__.__dict__.get('remote_'+name)
        if local or remote:
            return True
        raise AttributeError('no attribute %r' % name)

    def _check_permissions(self):
        try:
            current_state = self._sftp.stat(self._permission_file)
        except Exception:
            try:
                LOGGER.info('connection dropped, attempting to reestablish')
                self._connect()
                current_state = self._sftp.stat(self._permission_file)
            except (SSHException, EOFError):
                self._sftp = None
                raise OSError(ENOLINK, 'remote link down')
        user = CONTEXT.user
        if current_state != self._permission_state or user in self._allowed_users and user not in self._active_users:
            LOGGER.debug('>>> reading permissions for %r...', user)
            with self._sftp.open(self._shares_file) as data:
                mounts = data.readlines()
            self._mount = set()
            for line in mounts:
                line = line.strip()
                if not line:
                    continue
                mount_point, options, source = line.split('\t')
                mount_point -= self._remote_root
                self._mount.add(mount_point)
            with self._sftp.open(self._permission_file) as data:
                permissions = iter(data.readlines())
            self._allowed_users = set(next(permissions).strip().split(','))
            LOGGER.debug('>>>   users: %r', self._allowed_users)
            # if current user does not have at least Consumer privilege, we're done
            if user not in self._allowed_users:
                # remove symbolic link in local fs
                # symlink = self._local_root / user / 'FnxFS'
                # symlink.unlink()
                return
            self._active_users = set([user])
            self._file_permissions[user] = user_permissions = {}
            self._folders[user] = user_folders = defaultdict(set)
            # add the FnxFS 'root' directory
            user_folders[Path('/')]
            user_permissions[Path('/')] = 0
            user_folders[Path('')]
            user_permissions[Path('')] = 0
            # add the symlink if it doesn't yet exist
            # logger.debug('>>>   checking for symlink')
            # if not fnxfs_symlink_target.exists():
            #     logger.debug('>>>   creating symlink: %s --> %s', self._local_root/user/'FnxFS', fnxfs_symlink_target)
            #     (self._local_root/user/'FnxFS').symlink(fnxfs_symlink_target)
            # process file
            target = user + ':'
            for line in permissions:
                line = line.strip()
                LOGGER.debug('>>>   %s', line)
                if not line.startswith((target, 'all:')):
                    continue
                oe_user, perm, fn = line.split(':')
                fn = Path(fn)
                file = fn.lstrip('/')
                path = fn.path.strip('/')
                ep = user_permissions.get(file, 0)
                pp = user_permissions.get(path, 0)
                LOGGER.debug('>>> %s %s %s', path, file, ep)
                if perm == 'none':
                    user_permissions[file] = ep | 0o0
                    user_permissions[path] = pp | 0o0
                    LOGGER.debug('  > %s %o', file, user_permissions[file])
                    LOGGER.debug('  > %s %o', path, user_permissions[path])
                elif perm == 'read' or perm in ('create', 'write') and not self._read_write:
                    user_permissions[file] = ep | 0o400
                    user_permissions[path] = pp | 0o500
                    LOGGER.debug('  > %s %o', file, user_permissions[file])
                    LOGGER.debug('  > %s %o', path, user_permissions[path])
                elif perm == 'write' and self._read_write:
                    user_permissions[file] = ep | 0o600
                    user_permissions[path] = pp | 0o500
                    LOGGER.debug('  > %s %o', file, user_permissions[file])
                    LOGGER.debug('  > %s %o', path, user_permissions[path])
                elif perm == 'create' and self._read_write:
                    user_permissions[file] = ep | 0o600
                    user_permissions[path] = pp | 0o700
                    LOGGER.debug('  > %s %o', file, user_permissions[file])
                    LOGGER.debug('  > %s %o', path, user_permissions[path])
                else:
                    raise FuseOSError('Corrupted permissions file')
                user_folders[path].add(file.filename)
                dirs = path.dir_elements
                if not dirs:
                    user_folders[Path('/')].add(path)
                    user_permissions[Path('/')] = 0o500
                    user_folders[Path('')].add(path)
                    user_permissions[Path('')] = 0o500
                else:
                    stem = dirs.pop(0)
                    for dir in dirs:
                        user_folders[stem].add(dir)
                        stem /= dir
                    user_folders[stem].add(path.filename)
            for folder in user_folders:
                LOGGER.debug('<<< %s [%o]: %r', folder, user_permissions[folder], user_folders[folder])
                LOGGER.debug('<-> %s', ', '.join(['%s %o' % (file, user_permissions[folder/file]) for file in user_folders[folder] if file not in user_folders]))
                if user_permissions[folder]:
                    user_permissions[folder/'README'] = 0o400
            self._permission_state = current_state

    def _local_check_access(self, path, mode):
        """
        raise error if user has no access; return owner's of file
        """
        # access() checks whether the calling process can access the file pathname.
        # If pathname is a symbolic link, it is dereferenced.
        #
        # The  mode  specifies  the accessibility check(s) to be performed, and is either the value F_OK,
        # or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for
        # the existence of the file.  R_OK, W_OK, and X_OK test whether the file exists and grants read,
        # write, and execute permissions, respectively.
        #
        # The check is done using the calling process's real UID and GID, rather than the effective IDs as
        # is done when actually attempting an operation (e.g., open(2)) on the file.  This allows set-user-ID
        # programs to  easily  determine the invoking user's authority.
        #
        # If the calling process is privileged (i.e., its real UID is zero), then an X_OK check is successful
        # for a regular file if execute permission is enabled for any of the file owner, group, or other.
        #
        # RETURN VALUE
        # On success (all requested permissions granted), zero is returned.  On error (at least one bit in
        # mode asked for a permission that is denied, or some other error occurred), -1 is returned, and
        # errno is set appropriately.
        #
        # ERRORS
        # access() shall fail if:
        #
        # EACCES The requested access would be denied to the file, or search permission is denied for one of
        # the directories in the path prefix of pathname.  (See also path_resolution(7).)
        #
        # ELOOP  Too many symbolic links were encountered in resolving pathname.
        #
        # ENAMETOOLONG
        #       pathname is too long.
        #
        # ENOENT A component of pathname does not exist or is a dangling symbolic link.
        #
        # ENOTDIR
        #       A component used as a directory in pathname is not, in fact, a directory.
        #
        # EROFS  Write permission was requested for a file on a read-only file system.
        #
        # access() may fail if:
        #
        # EFAULT pathname points outside your accessible address space.
        #
        # EINVAL mode was incorrectly specified.
        #
        # EIO    An I/O error occurred.
        #
        # ENOMEM Insufficient kernel memory was available.
        #
        # ETXTBSY
        #       Write access was requested to an executable which is being executed.
        #
        LOGGER.debug('--- checking for %03o in %s', mode, path)
        file_stat = os.stat(path)
        LOGGER.debug('--- st_mode: %o', file_stat[ST_MODE])
        sticky_dir = file_stat[ST_MODE] & 0o2000
        if CONTEXT.uid == 0:
            LOGGER.debug('context is 0')
            # success if root, unless regular file without X, and X is requested
            if not is_dir(file_stat[ST_MODE]) and not file_stat[ST_MODE] & 0o111 and mode & os.X_OK:
                LOGGER.debug('calling _no_access')
                _no_access()
            LOGGER.debug('success, returning')
            return CONTEXT.uid, CONTEXT.gid, sticky_dir, file_stat[ST_GID]
        # normal user -- see if we can get to the file
        return check_rwx(os.stat(path), mode, CONTEXT, self._read_write)

    def init(self, path):
        pass

    def destroy(self, path):
        """
        called on file system destruction; path is always /
        """
        pass

    bmap = mknode = lock = None

    getxattr = listxattr = removexattr = setxattr = None

    def statfs(self, path):
        stv = os.statvfs(self._local_root)
        return dict(
                (key, getattr(stv, key))
                for key in (
                    'f_bavail', 'f_bfree', 'f_blocks',
                    'f_bsize', 'f_favail', 'f_ffree',
                    'f_files', 'f_flag', 'f_frsize', 'f_namemax',
                    ))

    def local_access(self, path, mode):
        self._local_check_access(path, mode)
        return 0

    def local_chmod(self, path, mode):
        file_stat = path.stat()
        if CONTEXT.uid == 0 or file_stat[ST_UID] == CONTEXT.uid:
            os.chmod(path, mode)
            return 0
        _no_access()

    def local_chown(self, path, uid, gid):
        file_stat = path.stat()
        if CONTEXT.uid == 0:
            os.chown(path, uid, gid)
            return 0
        if file_stat[ST_UID] != uid:
            _no_access()
        if gid not in _get_groups_ids(CONTEXT.user, CONTEXT.uid, CONTEXT.gid):
            _no_access()
        os.chown(path, uid, gid)
        return 0

    def local_create(self, path, mode):
        if non_ascii(path):
            raise OSError(EINVAL, 'non-ASCII characters in name')
        uid, gid, sticky_dir, sgid = self._local_check_access(path.path, os.W_OK|os.X_OK)
        if sticky_dir:
            gid = sgid
        fh = os.open(path, os.O_RDWR | os.O_CREAT, mode)
        os.chown(path, uid, gid)
        return fh

    def local_flush(self, path, fh):
        return os.fsync(fh)

    def local_fsync(self, path, datasync, fh):
        return os.fsync(fh)

    local_fsyncdir = _auto_success

    def local_getattr(self, path, fh=None):
        self.local_access(path.path, os.R_OK|os.X_OK)
        elements = CONTEXT.original_path.elements
        st = os.lstat(path)
        result = dict(
                (key, getattr(st, key))
                for key in
                    ('st_atime', 'st_ctime', 'st_gid', 'st_mode',
                     'st_mtime', 'st_nlink', 'st_size', 'st_uid')
                )
        if not self._read_write:
            # remove writable bits if in read-only mode
            result['st_mode'] = result['st_mode'] & 0o7777555
        return result

    def local_link(self, target, source):
        # TODO: check for cross-FnxFS boundaries
        # source: ['/', user, file_or_path] -- hopefully ;)
        source = Path(source)
        if (self._local_root/source).exists():
            source = self._local_root/source
        if source.elements[2:3] == ['FnxFS']:
            _no_access()
        self.local_access(source, os.F_OK)
        self.local_access(target.path, os.W_OK|os.X_OK)
        LOGGER.debug('--- source: %s', source)
        LOGGER.debug('--- target: %s', target)
        return os.link(source, target)

    local_lock = _auto_success      # TODO: make this actually work

    def local_mkdir(self, path, mode=None):
        uid, gid, sticky_dir, sgid = self._local_check_access(path.path, os.W_OK|os.X_OK)
        if sticky_dir:
            gid = sgid
        if mode is None:
            os.mkdir(path)
        else:
            os.mkdir(path, mode)
        os.chown(path, uid, gid)
        return 0

    def local_open(self, file, flags, mode=None):
        # 0b00 = READ-ONLY
        # 0b01 = WRITE-ONLY
        # 0b02 = READ-WRITE
        rw_flags = flags & 3
        perms = 0
        if not rw_flags or rw_flags & os.O_RDWR:
            perms |= os.R_OK
        if rw_flags:
            perms |= os.W_OK
        self._local_check_access(file, perms)
        if mode is None:
            return os.open(file, flags)
        else:
            return os.open(file, flags, mode)

    def local_opendir(self, path):
        self._local_check_access(path, os.R_OK)
        LOGGER.debug('--- %r', path.elements)
        elements = CONTEXT.original_path.elements
        if len(elements) == 2 and self._sftp is not None:
            LOGGER.debug('--- a home directory')
            LOGGER.debug('--- checking permissions file')
            user, CONTEXT.user = CONTEXT.user, elements[1]
            with DATA_LOCK:
                self._check_permissions()
            CONTEXT.user = user
        return 0

    def local_read(self, path, size, offset, fh):
        # with self.rwlock:
            os.lseek(fh, offset, 0)
            return os.read(fh, size)

    def local_readdir(self, path, fh):
        files = list(scandir(path))
        scan_files = set([f.name for f in files])
        elements = CONTEXT.original_path.elements
        return_files = ['.', '..']
        if len(elements) == 2 and elements[1] in self._allowed_users:
            LOGGER.debug('--- adding FnxFS')
            return_files.append('FnxFS')
        for f in files:
            st = f.stat(follow_symlinks=False)
            return_files.append((
                f.name,
                dict(
                    st_atime = st.st_atime,
                    st_blksize = st.st_blksize,
                    st_blocks = st.st_blocks,
                    st_ctime = st.st_ctime,
                    st_dev = st.st_dev,
                    st_gid = st.st_gid,
                    st_ino = st.st_ino,
                    st_mode = st.st_mode,
                    st_mtime = st.st_mtime,
                    st_nlink = st.st_nlink,
                    st_rdev = st.st_rdev,
                    st_size = st.st_size,
                    st_uid = st.st_uid,
                    ),
                0,
                ))
        self.seen_files.add(CONTEXT.user, path, scan_files)
        return return_files

    local_readlink = os.readlink

    def local_release(self, path, fh):
        return os.close(fh)

    local_releasedir = _auto_success

    def local_rename(self, old, new):
        # TODO: check if logic needed to ensure renames don't cross
        # FnxFS boundary
        #
        # old has already been adjusted, so we just need to adjust
        # new
        if Path(new).elements[2:3] == ['FnxFS']:
            _no_access()
        self._local_check_access(old.path, os.W_OK|os.X_OK)
        new = self._local_root / new
        self._local_check_access(new.path, os.W_OK|os.X_OK)
        os.rename(old, new)
        return 0

    def local_rmdir(self, path):
        self._local_check_access(path.path, os.W_OK|os.X_OK)
        os.rmdir(path)
        return 0

    def local_symlink(self, target, source):
        if Path(source).elements[2:3] == ['FnxFS']:
            # TODO: may want to enable this someday
            _no_access()
        uid, gid, sticky_dir, sgid = self._local_check_access(target.path, os.W_OK)
        if sticky_dir:
            gid = sgid
        LOGGER.debug('--- source: %s', source)
        LOGGER.debug('--- target: %s', target)
        os.symlink(source, target)

    def local_truncate(self, path, length):
        self._local_check_access(path, os.W_OK)
        with open(path, 'r+') as f:
            f.truncate(length)
        return 0

    def local_unlink(self, path):
        LOGGER.debug('--- checking access on %s', path.path)
        self._local_check_access(path.path, os.W_OK)
        LOGGER.debug('--- unlinking')
        os.unlink(path)
        return 0

    def local_utimens(self, path, times):
        self._local_check_access(path, os.W_OK)
        os.utime(path, times)
        return 0

    def local_write(self, path, data, offset, fh):
        # with self.rwlock:
            os.lseek(fh, offset, 0)
            return os.write(fh, data)

    def _check_mount(self, folder):
        LOGGER.info('--- _check_mount: %r', folder)
        LOGGER.debug('*-* %r', self._mount)
        mount_point = self._remote_root/folder
        files = self._sftp.listdir_attr(mount_point)
        LOGGER.debug('--- %r', files)
        if not files:
            LOGGER.debug('*-* no files found, attempting to lazy mount')
            # should be no empty shares
            if not self._server_connect():
                raise OSError((ENOLINK, 'unable to contact server'))
            self._mount_remote(folder)
            files = self._sftp.listdir_attr(mount_point)
            LOGGER.debug('--- %r', files)
        return files

    def _mount_remote(self, mount):
        LOGGER.debug('/// running mount command for %r...', mount)
        stdin, stdout, stderr = self._server.exec_command('/usr/local/bin/fnxfs shares start "%s"' % (mount,))
        LOGGER.debug('/// attempting communication...')
        sleep(1)
        LOGGER.debug('/// stdout: %r', stdout.read())
        LOGGER.debug('/// stderr: %r', stderr.read())
        stdin.close()
        stdout.close()
        stderr.close()
        self._server.close()

    def _get_perms(self, path, remote_st=None, directory=False):
        """
        path exists remotely -- what are user's permissions locally?
        """
        LOGGER.debug('+++ %s ||%s||', path, remote_st)
        if self._remote_root in path:
            target = (path - self._remote_root).lstrip('/')
        else:
            target = path
        if target in ('', '/'):
            LOGGER.debug('+++ perms: 0o555')
            return 0o555
        if _is_hidden_or_swap(path):
            LOGGER.debug('+++ hidden file: 0o600')
            return 0o600
        LOGGER.debug('+++ path: %s', target.path)
        LOGGER.debug('+++ file: %s', target.filename)
        user = CONTEXT.user
        with DATA_LOCK:
            permissions = self._file_permissions[user]
            folders = self._folders[user]
            if target in permissions:
                LOGGER.debug('+++ found: %o', permissions[target])
                return permissions[target]
            path = self._find_path(path)
            if directory:
                return permissions.get(path, 0)
            else:
                return permissions.get(path/'*', 0)

    def _find_path(self, path):
        """
        Finds most specific path specified in permissions file.
        """
        with DATA_LOCK:
            folders = self._folders[CONTEXT.user]
            LOGGER.debug('*** path: %s', path)
            if self._remote_root in path:
                lookup = (path - self._remote_root).lstrip('/') # or Path('/')
            else:
                lookup = path
            if lookup in folders:
                LOGGER.debug('*** lookup: %s', lookup)
                return lookup
            elements = lookup.elements
            found = elements and elements[0] or ''
            for next_ele in elements[1:]:
                if found/next_ele not in folders:
                    LOGGER.debug('*** failed: %s', found/next_ele)
                    break
                found /= next_ele
            LOGGER.debug('*** calced: %s', found)
            return found

    def _remote_check_access(self, path, mode, directory=False):
        """
        raise error if user has no access
        """
        user = CONTEXT.user
        LOGGER.debug('### user: %s', user)
        if _is_hidden_or_swap(path):
            return 0
        if CONTEXT.uid and CONTEXT.uid != CONTEXT.share_uid and len(path.elements) > 3:
            _no_access()
        # trim path to look like stored keys
        trimmed_path = reduce(op.div, path.elements[3:], Path('')).strip('/') or Path('/')
        LOGGER.debug('### %s', trimmed_path)
        file_perm = self._get_perms(trimmed_path, directory=directory)
        LOGGER.debug('### perm: %5o', file_perm)
        LOGGER.debug('### aces: %d', mode)
        if file_perm == 0:
            _no_access()
        # only the owner is allowed in to FnxFS, so only check the user permissions,
        # but only if the current user is the owner
        if CONTEXT.uid in (CONTEXT.share_uid, 0):
            result = (file_perm & 0o700) >> 6
        else:
            result = file_perm & 0o007
        if result & mode == mode:
            return 0
        _no_access()

    def remote_access(self, path, mode):
        return self._remote_check_access(CONTEXT.original_path, mode)

    def remote_chmod(self, path, mode):
        if CONTEXT.uid not in (0, CONTEXT.share_uid):
            _no_access()
        LOGGER.debug('--- changing mod (psyche!)')
        user = CONTEXT.user
        with DATA_LOCK:
            permissions = self._file_permissions[user]
            target = (path - self._remote_root).lstrip('/')
            LOGGER.debug('--- current: %o   requested: %o', permissions[target], mode)
            if permissions[target] != mode:
                _no_access()
            return 0

    def remote_chown(self, path, uid, gid):
        if CONTEXT.share_uid != uid or CONTEXT.share_gid != gid:
            _no_access()
        LOGGER.debug('--- changing ownership (psyche!)')
        return 0

    def remote_create(self, path, mode):
        if non_ascii(path):
            raise OSError(EINVAL, 'non-ASCII characters in name')
        if len(CONTEXT.original_path.elements) == 4:           # XXX check all length statements now that home is .shadowed!
            _no_access()
        if not _is_hidden_or_swap(path):
            LOGGER.debug('-@- not hidden nor swap, checking parent dir')
            self._remote_check_access(CONTEXT.original_path.path, os.W_OK|os.X_OK, directory=True)
        LOGGER.debug('-@- creating %s', path)
        self._sftp.open(path, mode='w+').close()
        self._sftp.chmod(path, mode)
        path -= self._remote_root
        user = CONTEXT.user
        with DATA_LOCK:
            permissions = self._file_permissions[user][path] = mode
            self._folders[user][path.dirs].add(path.filename)
            self._cache[user][path.dirs] = (mode, None)
        return 0

    remote_flush = _auto_success

    remote_fsync = _auto_success

    remote_fsyncdir = _auto_success

    def remote_getattr(self, path, fh=None):
        start_time = time()
        user = CONTEXT.user
        with DATA_LOCK:
            permitted, remote_st = self._cache[user].pop(path, (0, None))
        if remote_st is None:
            LOGGER.debug('--- remote_st is None')
            # this could probably use more fine-tuning... for now, ONLY do a
            # permissions check for getattr calls that aren't cached, otherwise
            # we kill performance
            with DATA_LOCK:
                if time() - self._last_permissions_check >= SERVER_DELAY:
                    self._last_permissions_check = time()
                    self._check_permissions()
            LOGGER.debug('--- %s', path.path)
            self._remote_check_access(CONTEXT.original_path.path, os.R_OK|os.X_OK, directory=True)
            try:
                remote_st = self._sftp.lstat(path)
            except IOError:
                exc = sys.exc_info()[1]
                err_text = errorcode.get(exc.errno, str(exc))
                raise OSError(exc.errno, err_text)
            except:
                exc = sys.exc_info()[1]
                LOGGER.exception(exc)
                raise
            if not permitted:
                permitted = self._get_perms(path, remote_st)
        local_st = dict((key, getattr(remote_st, key)) for key in (
            'st_atime', 'st_mode', 'st_mtime', 'st_size',
            ))
        local_st['st_uid'] = CONTEXT.share_uid
        local_st['st_gid'] = CONTEXT.share_gid
        local_st['st_nlink'] = 1
        if not permitted and path != self._remote_root:
            raise OSError(ENOENT, errorcode[ENOENT])
        if permitted and is_dir(local_st['st_mode']):
            permitted |= 0o100
        local_st['st_mode'] = remote_st.st_mode & 0o777000 | permitted
        LOGGER.debug('--- local_st = %s', local_st)
        LOGGER.debug('--- remote getattr duration: %s', time() - start_time)
        return local_st

    remote_link = _no_support

    remote_lock = None

    def remote_mkdir(self, path, mode=None):
        self._remote_check_access(CONTEXT.original_path.path, os.W_OK|os.X_OK, directory=True)
        self._sftp.mkdir(path)
        return 0

    remote_mknod =  _no_access

    def remote_open(self, path, flags, mode=None):
        # 0b00 = READ-ONLY
        # 0b01 = WRITE-ONLY
        # 0b02 = READ-WRITE
        rw_flags = flags & 3
        perms = 0
        if not rw_flags or rw_flags and os.O_RDWR:
            perms |= os.R_OK
        if rw_flags:
            perms |= os.W_OK
        self._remote_check_access(CONTEXT.original_path, perms)
        return 0

    def remote_opendir(self, path):
        if CONTEXT.uid == CONTEXT.share_uid or CONTEXT.uid == 0:
            return self._remote_check_access(CONTEXT.original_path, os.R_OK)
        _no_access()

    def remote_read(self, path, size, offset, fh):
        f = self._sftp.open(path)
        f.seek(offset, 0)
        buf = f.read(size)
        f.close()
        return buf

    def remote_readdir(self, path, _fh):
        start_time = time()
        with DATA_LOCK:
            if time() - self._last_permissions_check > SERVER_DELAY:
                self._last_permissions_check = time()
                self._check_permissions()
            def get_remote_files(path, common_folder=None):
                files = self._sftp.listdir_attr(path)
                if not files:
                    if common_folder is None:
                        common_folder = self._find_path(path)
                    if common_folder in self._mount:
                        files = self._check_mount(common_folder)
                        if common_folder != path:
                            files = self._sftp.listdir_attr(path)
                return common_folder, files
            user = CONTEXT.user
            logging.debug('### user: %s', user)
            cache = self._cache[user]
            permissions = self._file_permissions[user]
            folders = self._folders[user]
            logging.debug('### permissions: %r', permissions)
            key = (path - self._remote_root).lstrip('/')
            logging.debug('### key: %r', key)
            if key in folders:
                logging.debug('### key was in folders')
                names = []
                items = []
                default_perm = permissions.get(key/'*', 0)
                _, files = get_remote_files(path)
                logging.debug('### remote files: %r', [a.filename for a in files])
                for f in files:
                    filename = f.filename
                    target = key and key/filename or filename
                    perms = permissions.get(target, default_perm)
                    if perms and not is_link(f.st_mode):
                        names.append(filename)
                        file_st = dict(
                                st_uid=CONTEXT.share_uid,
                                st_gid=CONTEXT.share_gid,
                                st_atime=f.st_atime,
                                st_mtime=f.st_mtime,
                                st_size=f.st_size,
                                st_mode=f.st_mode & 0o777000 | perms,
                                )
                        items.append((filename, file_st, 0))
                        cache[path/filename] = perms, f
            else:
                logging.debug('### key not in folders')
                # we are looking at an inherited folder; check global permissions
                common_folder = self._find_path(path)
                perms = permissions.get(common_folder, 0)
                names = []
                items = []
                if perms:
                    _, files = get_remote_files(path, common_folder)
                    for f in files:
                        if not is_link(f.st_mode):
                            names.append(f.filename)
                            file_st = dict(
                                    st_uid=CONTEXT.share_uid,
                                    st_gid=CONTEXT.share_gid,
                                    st_atime=f.st_atime,
                                    st_mtime=f.st_mtime,
                                    st_size=f.st_size,
                                    st_mode=f.st_mode & 0o777000 | perms,
                                    st_nlink=1,
                                    )
                            items.append((f.filename, file_st, 0))
                            cache[path/f.filename] = perms, f
            self.seen_files.add(user, self._home/user/'FnxFS'/key, names)
            LOGGER.debug('--- remote_readdir duration: %s', time() - start_time)
            return items
            # return names

    def remote_readlink(self, path):
        raise OSError(ENOENT, 'no such file')

    def remote_release(self, path, fh):
        """
        archive this file unless it is hidden or has a lockfile or is a lockfile
        """
        hidden = _is_hidden_or_swap(path)
        lock_file = _is_lock_file(path, error=False)
        if hidden or lock_file:
            # hidden and lock files are not archived
            return 0
        elif not lock_file:
            # this is not a lock file, check if one exists
            if _get_lockfile(self._sftp, path):
                # one does, archive later
                return 0
        # at this point this is a normal file that needs to be archived, iif data was written to it
        with DATA_LOCK:
            possibly_archive(self._client, self._written[CONTEXT.user], path)
        return 0

    remote_releasedir = _auto_success

    def remote_rename(self, current, new):
        """
        'current' must be a hidden or lock file
        'new' must exist and be writable
        """
        with DATA_LOCK:
            hidden = _is_hidden_or_swap(current)
            if not hidden:
                LOGGER.debug('*** attempt to rename a regular file')
                self._remote_check_access(CONTEXT.original_path.path, os.W_OK|os.X_OK, directory=True)
            new = Path(new)
            if new.elements[2:3] != ['FnxFS']:
                LOGGER.debug('*** cannot move FnxFS file outside FnxFS')
                _no_access()
            self._remote_check_access(new, os.W_OK)
            new = self._remote_root / '/'.join(new.elements[3:])
            # self._remote_check_access(new.path, os.W_OK|os.X_OK)
            try:
                self._sftp.remove(new)
            except IOError:
                pass
            self._sftp.rename(current, new)
            user = CONTEXT.user
            self._written[user].add(new)
            if current in self._written[user]:
                self._written[user].remove(current)
        return 0

    def remote_rmdir(self, path):
        self._remote_check_access(CONTEXT.original_path.path, os.W_OK|os.X_OK, directory=True)
        self._sftp.rmdir(path)
        return 0

    remote_symlink = _no_support

    def remote_truncate(self, path, length, fh=None):
        with DATA_LOCK:
            self._remote_check_access(CONTEXT.original_path, os.W_OK)
            self._written[CONTEXT.user].add(path)
            return self._sftp.truncate(path, length)

    def remote_unlink(self, path):
        with DATA_LOCK:
            hidden = _is_hidden_or_swap(path)
            lock_file = _is_lock_file(path, error=False)
            if not hidden and not lock_file:
                self._remote_check_access(CONTEXT.original_path.path, os.W_OK|os.X_OK, directory=True)
                self._sftp.unlink(path)
                return 0
            if hidden:
                self._sftp.unlink(path)
                if not lock_file:
                    return 0
            # must be a lockfile; if the file ever had data written to it, archive it
            path = _locked_file_from(path)
            possibly_archive(self._client, self._written[CONTEXT.user], path)
        return 0

    def remote_utimens(self, path, times=None):
        self._remote_check_access(CONTEXT.original_path.path, os.W_OK)
        self._sftp.utime(path, times)
        return 0

    def remote_write(self, path, data, offset, fh):
        with DATA_LOCK:
            self._written[CONTEXT.user].add(path)
            f = self._sftp.open(path, 'r+')
            f.seek(offset, 0)
            f.write(data)
            f.flush()
            f.close()
            return len(data)


class Accessed(object):
    """
    Keep track of files that have been seen (readdir).
    """

    max_size = 5192
    trim_size = 3072

    def __init__(self):
        self.cache = defaultdict(lambda: defaultdict(list))
        self.paths = defaultdict(list)

    def add(self, user, path, files):
        """
        add, or update, files into the cache
        """
        if user == 'root':
            # don't track root access
            return
        elements = path.elements
        if path.startswith((SHADOW, FNXFS_SHADOW)):
            elements.pop(2)
            path = reduce(op.div, elements)
        with DATA_LOCK:
            try:
                self.paths[user].remove(path)
            except ValueError:
                pass
            self.paths[user].append(path)
            self.cache[user][path] = files
            total = sum([len(f) for f in self.cache[user].values()])
            if total > self.max_size:
                self._shrink(user, total)

    def _shrink(self, user, count):
        """
        reduce cache to most recent seen files
        """
        seen_paths = list(reversed(self.paths[user]))
        while count > self.trim_size:
            victim = seen_paths.pop()
            files = self.cache[user].pop(victim)
            count -= len(files)
        self.paths[user][:] = list(reversed(seen_paths))

    def find(self, user, file_name):
        """
        return the path of file -- if more than one match, use the most recent
        """
        LOGGER.warning('checking %r for %r', user, file_name)
        with DATA_LOCK:
            for path in reversed(self.paths[user]):
                files = self.cache[user][path]
                if file_name in files:
                    return path

def _start(timeout):
    # ideal setup
    #   /home/.shadow has user data
    #   /home/.fnxfs_mirror does not exist
    # recoverable setups
    #   /home/.shadow doesn't exist or is empty
    #   /home/.fnxfs_mirror does exist, and has data
    # unrecoverable setup
    #   /home/.shadow exists with data
    #   /home/.fnxfs_mirror exists
    #   (hopefully this means the daemon is already running!)
    lock = PidLockFile(PIDFILE)
    try:
        lock.acquire()
    except AlreadyLocked:
        abort('fnxfsd already running')
    lock.release()
    if FNXFS_SHADOW.exists() and SHADOW.exists() and SHADOW.listdir():
        abort('both %s and %s already exist!' % (SHADOW, FNXFS_SHADOW))
    if SHADOW.exists() and SHADOW.listdir():
        print('moving %s to %s...' % (SHADOW, FNXFS_SHADOW))
        SHADOW.rename(FNXFS_SHADOW)
    if not SHADOW.exists():
        print('creating %s mount point...' % SHADOW)
        SHADOW.mkdir()
    print('mounting: fnxfsd %s %s' % (FNXFS_SHADOW, SHADOW))
    result = Execute('fnxfsd %s %s' % (FNXFS_SHADOW, SHADOW))
    if result.returncode:
        print(result.stdout, verbose=0)
        print(result.stderr, file=stderr)
        raise SystemExit(result.returncode)
    tries = wait_and_check(timeout)
    while tries:
        exc = None
        try:
            found = SHADOW.listdir()
            print(found, verbose=2)
        except Exception, exc:
            print(exc, verbose=2)
            pass
        else:
            if found:
                break
    else:
        if exc:
            print(traceback.format_exc(exc), verbose=0)
        print('problem mounting %s!  reverting...' % SHADOW, verbose=0)
        _stop()

def _squat():
    global TARGET
    if FNXFS_SHADOW.exists():
        squatt = FNXFS_SHADOW
    else:
        squatt = SHADOW
    # make sure the directory doesn't change out from beneath our feet
    # while we are moving data around
    squatt.chdir()
    TARGET = squatt

def _stop():
    print('unmounting %s...' % SHADOW)
    result = Execute('umount %s' % SHADOW)
    if result.returncode:
        print(result.stdout, verbose=0)
        print(result.returncode, result.stderr, file=stderr)
        raise SystemExit(result.returncode)
    exc = None
    retries = wait_and_check(10)
    while retries:
        try:
            found = SHADOW.listdir()
            if not found:
                break
        except Exception, exc:
            pass
    else:
        if exc is not None:
            raise exc
        raise SystemExit('unable to unmount %s' % SHADOW)
    print('removing %s...' % SHADOW)
    SHADOW.rmdir()
    print('moving %s to %s' % (FNXFS_SHADOW, SHADOW))
    FNXFS_SHADOW.rename(SHADOW)


if __name__ == "__main__":
    Run()
