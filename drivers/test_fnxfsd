#!/usr/local/bin/suid-python
from dbf import DateTime
from getpass import getpass
from path import Path
from pwd import getpwall as get_system_users
from grp import getgrall as get_system_groups
from scription import *
from unittest import TestCase, main as test
import functools
import os
import subprocess
import sys
import time
import types

#####################
# set up and prepare
#####################

@Script(
        live_daemon=Spec('test the installed daemon', FLAG, remove=True),
        verbose=Spec('more info on tests', FLAG),
        tests=Spec('specific tests to run', OPTION),
        )
def main(live_daemon, verbose, *tests):
    global daemon, generate_log, root_password
    os.umask(0)
    if os.getuid() != 0 and os.geteuid() != 0:
        raise SystemExit('tests must be run as root')
    get_test_users()
    if len(users_in_same_group) == 1:
        raise SystemExit('user %r must be in the same group as at least one other user' % actual_user.pw_name)
    if not users_in_different_group:
        raise SystemExit('need at least one user with no common group as %r' % actual_user.pw_name)
    Path('.').remove('success')
    with open('password') as pass_file:
        root_password = pass_file.read().strip()
    if live_daemon:
        daemon = installed_daemon
    else:
        daemon = devel_daemon
    generate_log = bool(tests)
    try:
        # remove_dirs()
        create_dirs()
        result = test()
    except SystemExit, exc:
        if exc.code == 0:
            open('success', 'w').close()
    finally:
        remove_dirs()

pyver = sys.version_info[:2]
not_suid = True
if os.getuid() != 0:
    not_suid = False

system_users = get_system_users()
system_groups = get_system_groups()
cwd = Path.getcwd()
home = cwd / 'mount'
local = cwd / 'local'
remote = cwd / 'remote'
perm_file = cwd / 'fnxfs.permissions'
shares_file = cwd / 'fnxfs.mount'
test_conf = cwd / 'test.conf'
common_files = [
        'index.txt',
        '.profile',
        '.bashrc',
        '.vimrc',
        'prefs',
        'Desktop/selfie.png',
        'Desktop/logo.jpg',
        'Public/motto.txt',
        ]
common_folders = [
        '.mozilla',
        'Desktop',
        'Public',
        'Public/letters',
        ]
remote_files = [
        'Accounting/invisible.txt',
        'Accounting/visible.txt',
        'Accounting/Acct Rec/debts.osv',
        'Accounting/Acct Pay/instruct.txt',
        'Misc/daily_stats.pdf',
        ]
installed_daemon = Path('/usr/local/sbin/fnxfsd')
devel_daemon = Path('./fnxfsd')

# taken from the 2.7 libs
class SkipTest(Exception):
    """
    Raise this exception in a test to skip it.

    Usually you can use TestResult.skip() or one of the skipping decorators
    instead of raising this directly.
    """
    pass

def _id(obj):
    return obj

def skip(reason):
    """
    Unconditionally skip a test.
    """
    def decorator(test_item):
        if not isinstance(test_item, (type, types.ClassType)):
            @functools.wraps(test_item)
            def skip_wrapper(*args, **kwargs):
                raise SkipTest(reason)
            test_item = skip_wrapper

        test_item.__unittest_skip__ = True
        test_item.__unittest_skip_why__ = reason
        return test_item
    return decorator

def skipIf(condition, reason):
    """
    Skip a test if the condition is true.
    """
    if condition:
        return skip(reason)
    return _id

def skipUnless(condition, reason):
    """
    Skip a test unless the condition is true.
    """
    if not condition:
        return skip(reason)
    return _id

def check_output(*popenargs, **kwargs):
    """
    Run command with arguments and return its output as a byte string.
    """
    if 'stdout' in kwargs:
        raise ValueError('stdout argument not allowed, it will be overridden.')
    process = subprocess.Popen(stdout=subprocess.PIPE, *popenargs, **kwargs)
    output, unused_err = process.communicate()
    retcode = process.poll()
    if retcode:
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = popenargs[0]
        raise subprocess.CalledProcessError(retcode, cmd, output=output)
    return output


###############
# Actual Tests
###############

class TestLocalFS(TestCase):

    def setUp(self):
        # make sure we're root
        os.setreuid(actual_user_id, 0)
        os.setregid(actual_user.pw_gid, 0)
        self.tearDown()
        for user in users + users_in_different_group[0:1]:
            home_user = home/user.pw_name
            local_user = local/user.pw_name
            user_ids = user.pw_uid, user.pw_gid
            local_user.mkdir()
            local_user.chmod(0o755)
            local_user.chown(*user_ids)
            stat = local_user.stat()
            self.assertEqual((stat.st_uid, stat.st_gid), user_ids)
            stat = home_user.stat()
            self.assertEqual((stat.st_uid, stat.st_gid), user_ids)
            for folder in common_folders:
                user_folder = local_user/folder
                user_folder.mkdir()
                user_folder.chmod(0o755)
                user_folder.chown(*user_ids)
                stat = user_folder.stat()
                self.assertEqual((stat.st_uid, stat.st_gid), user_ids)
                stat = (home_user/folder).stat()
                self.assertEqual((stat.st_uid, stat.st_gid), user_ids)
            for i, file in enumerate(common_files):
                user_file = local_user/file
                with open(user_file, 'w') as f:
                    f.write(str(i))
                user_file.chmod(0o640)
                user_file.chown(*user_ids)
                stat = user_file.stat()
                self.assertEqual((stat.st_uid, stat.st_gid), user_ids)
                stat = (home_user/file).stat()
                self.assertEqual(
                        (stat.st_uid, stat.st_gid),
                        user_ids,
                        'file %s [%r] does not match %s [%r]' % (home_user/file, (stat.st_uid, stat.st_gid), user_file, user_ids))
        self.target_file = home/actual_user.pw_name/common_files[0]
        self.local_file = local/actual_user.pw_name/common_files[0]

    def tearDown(self):
        # make sure we're root
        os.setreuid(actual_user_id, 0) 
        for subdir in local.listdir():
            local.rmtree(subdir)

    @skipIf(not_suid, 'test should be run as a normal user')
    def test_access_as_root(self):
        """
        can test for file existence, or read|write|execute, but is based on the real user
        """
        # check as root, which should only fail if X_OK is asked for, but the execution bit is
        # not set for any of user/group/other
        os.setreuid(0, actual_user_id)
        os.setregid(0, actual_user.pw_gid)
        target_file = self.target_file
        for perms, executable in all_perms(suid=True):
            target_file.chmod(perms)
            for request in range(1, 8):
                self.assertEqual(target_file.access(0), True)
                should_succeed = True
                if (request & 1) and (((perms & 0o700) >> 6 | (perms & 0o070) >> 3 | (perms & 0o007)) & 1 != 1):
                    should_succeed = False
                self.assertEqual(
                        target_file.access(request),
                        should_succeed,
                        'file %s with perms of %03o failed request of %03o (should_succeed: %s' % (target_file, perms, request, should_succeed))
        os.setreuid(actual_user_id, 0)

    @skipIf(not_suid, 'test should be run as a normal user')
    def test_access_as_user(self):
        """
        can test for file existence, or read|write|execute, but is based on the real user
        """
        target_file = self.target_file
        for perms, executable in all_perms(suid=True):
            target_file.chmod(perms)
            for request in range(1, 8):
                # request represents the bit position which represents the permission we are asking for:
                #  1 -> execute
                #  2 -> write
                #  3 -> read
                should_succeed = ((perms & 0o700) >> 6 | (perms & 0o070) >> 3 | (perms & 0o007)) & request == request
                self.assertEqual(target_file.access(0), True)
                self.assertEqual(
                        target_file.access(request),
                        should_succeed,
                        'file %s with perms of %03o failed request of %03o (should_succeed: %s)' % (target_file, perms, request, should_succeed))

    def test_chmod_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        target_file = self.target_file
        local_file = self.local_file
        for user in users:
            for perms, _ in all_perms(suid=True):
                    target_file.chmod(perms)
                    self.assertEqual(target_file.stat().st_mode, local_file.stat().st_mode)

    def test_chmod_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = local/user.pw_name/common_files[0]
            for perms, _ in all_perms(suid=True):
                if user.pw_uid == actual_user_id:
                    target_file.chmod(perms)
                    self.assertEqual(target_file.stat().st_mode, local_file.stat().st_mode)
                else:
                    check_exception(OSError(13, 'denied'), target_file.chmod, perms)

    def test_chown_group(self):
        """
        owner can only change the group owner to a group the owner belongs to
        """
        # lose root privilege
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        uncommon_gid = different_groups[0].gr_gid
        common_gid = common_groups[-1].gr_gid
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            check_exception(OSError(13, 'denied'), target_file.chown, user.pw_uid, uncommon_gid)
            target_file.chown(user.pw_uid, common_gid)
            stat = target_file.stat()
            mounted = stat.st_uid, stat.st_gid
            stat = (local/user.pw_name/common_files[0]).stat()
            master = stat.st_uid, stat.st_gid
            self.assertEqual(mounted, master)
            self.assertEqual(master, (user.pw_uid, common_gid))
        # grab root privilege back
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target_user = user.pw_uid, uncommon_gid
            mirrored_file = home/user.pw_name/common_files[0]
            source_file = local/user.pw_name/common_files[0]
            mirrored_file.chown(*target_user)
            mirrored_stat = mirrored_file.stat()
            source_stat = source_file.stat()
            self.assertEqual((mirrored_stat.st_uid, mirrored_stat.st_gid), target_user)
            self.assertEqual((source_stat.st_uid, source_stat.st_gid), target_user)

    def test_chown_user(self):
        """
        only root can change ownership (although it can be "changed" to what it already is
        """
        # lose root privilege
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        target_user = actual_user.pw_uid, actual_user.pw_gid
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            if user is actual_user:
                target_file.chown(*target_user)
            else:
                check_exception(OSError(13, 'denied'), target_file.chown, *target_user)
        # grab root privilege back
        os.seteuid(0)
        for user in users:
            mirrored_file = home/user.pw_name/common_files[0]
            source_file = local/user.pw_name/common_files[0]
            mirrored_file.chown(*target_user)
            mirrored_stat = mirrored_file.stat()
            source_stat = source_file.stat()
            self.assertEqual((mirrored_stat.st_uid, mirrored_stat.st_gid), target_user)
            self.assertEqual((source_stat.st_uid, source_stat.st_gid), target_user)

    def test_create_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            # create a file the normal way
            target_folder = home/user.pw_name/common_folders[0]
            local_folder = local/user.pw_name/common_folders[0]
            open(target_folder/'success', 'w').close()
            self.assertTrue((local_folder/'success').exists())
            self.assertTrue((target_folder/'success').exists())
            stat = target_folder.stat('success')
            self.assertEqual((stat.st_uid, stat.st_gid), (0, os.getegid()))
            self.assertEqual(
                    stat.st_mode & 0o777,
                    0o666,
                    'permissions should be 0o666, but got %03o -- umask set correctly?' % stat.st_mode,
                    )
            target_folder.remove('success')
        for perms, _ in all_perms(suid=True):
            # create a file and specify the permissions
            fd = os.open(target_folder/'success', os.O_RDWR|os.O_CREAT, perms)
            os.close(fd)
            self.assertTrue((local_folder/'success').exists())
            self.assertTrue((target_folder/'success').exists())
            stat = target_folder.stat('success')
            self.assertEqual((stat.st_uid, stat.st_gid), (0, 0))
            target_folder.remove('success')

    def test_create_as_user(self):
        # TODO: add test for mode as well
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target_folder = home/user.pw_name/common_folders[0]
            local_folder = local/user.pw_name/common_folders[0]
            if user.pw_uid == actual_user_id:
                open(target_folder/'success', 'w').close()
                stat = target_folder.stat('success')
                self.assertEqual((stat.st_uid, stat.st_gid), (actual_user_id, actual_user.pw_gid))
                stat = local_folder.stat('success')
                self.assertEqual((stat.st_uid, stat.st_gid), (actual_user_id, actual_user.pw_gid))
                target_folder.remove('success')
            else:
                check_exception(IOError(13, 'denied'), open, target_folder/'success', 'w')
            target_folder.remove('success')
            for perms, _ in all_perms(suid=True):
                if user.pw_uid == actual_user_id:
                    fd = os.open(target_folder/'success', os.O_RDWR|os.O_CREAT, perms)
                    os.close(fd)
                    stat = target_folder.stat('success')
                    self.assertEqual((stat.st_uid, stat.st_gid), (actual_user_id, actual_user.pw_gid))
                    stat = local_folder.stat('success')
                    self.assertEqual((stat.st_uid, stat.st_gid), (actual_user_id, actual_user.pw_gid))
                    target_folder.remove('success')
                else:
                    check_exception(IOError(13, 'denied'), open, target_folder/'success', 'w')


    def test_link_as_root(self):
        # basic permissions -- FnxFS related links will be handled elsewhere
        os.seteuid(0)
        os.setegid(0)
        for i, user in enumerate(users):
            source = home/user.pw_name/'sample.txt'
            with open(source, 'w') as f:
                f.write('abcdefghijklmnopqrstuvwxyz')
            for link_user in users:
                new_name = home/link_user.pw_name/'Public/letters/alphabet.txt'
                source.link(new_name)
                with open(new_name) as test:
                    self.assertEqual(test.read(), 'abcdefghijklmnopqrstuvwxyz')
                new_name.remove()

    def test_link_as_user(self):
        # basic permissions -- FnxFS related links will be handled elsewhere
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        source = home/actual_user.pw_name/'sample.txt'
        with open(source, 'w') as f:
            f.write('abcdefghijklmnopqrstuvwxyz')
        for link_user in users:
            new_name = home/link_user.pw_name/'Public/letters/alphabet.txt'
            if link_user is actual_user:
                source.link(new_name)
                with open(new_name) as test:
                    self.assertEqual(test.read(), 'abcdefghijklmnopqrstuvwxyz')
                new_name.remove()
            else:
                check_exception(OSError(13, 'denied'), source.link, new_name)

    def test_mkdir_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            test = home/user.pw_name/'test'
            for perms, _ in all_perms():
                test.mkdir(mode=perms)
                stat = test.stat()
                self.assertEqual(stat.st_mode & 0o7777, perms, 'mismatch -- requested: %06o, got: %06o' % (perms, stat.st_mode))
                test.rmdir()
            test.mkdir(mode=0o2755)
            stat = test.stat()
            self.assertEqual(stat.st_mode & 0o7777, 0o0755, 'mismatch -- requested: 02755, expected: 00755, got: %06o' % stat.st_mode)

    def test_mkdir_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        test = home/actual_user.pw_name/'test'
        for perms, _ in all_perms():
            test.mkdir(mode=perms)
            stat = test.stat()
            self.assertEqual(stat.st_mode & 0o7777, perms, 'mismatch -- requested: %06o, got: %06o' % (perms, stat.st_mode))
            test.rmdir()
        test.mkdir(mode=0o2755)
        stat = test.stat()
        self.assertEqual(stat.st_mode & 0o7777, 0o0755, 'mismatch -- requested: 02755, expected: 00755, got: %06o' % stat.st_mode)

    def test_open_as_root(self):
        """
        test opening for read, write, read/write (which also tests reading and writing ;)
        """
        os.seteuid(0)
        os.setegid(0)
        target_file = self.target_file
        for perms in range(12):
            perms = 1 << perms
            target_file.chmod(perms)
            for mode in ('r', 'r+', 'a+'):
                with open(target_file, mode) as file:
                    file.seek(0)
                    data = file.read()
                    self.assertEqual(data, '0')
            text = '\n%03o\n' % perms
            for mode in ('w', 'r+', 'w+', 'a+'):
                with open(target_file, mode) as file:
                    file.write(text)
                with open(target_file, 'r') as file:
                    self.assertTrue(text in file.read())
                with open(target_file, 'w') as file:
                    file.write('0')

    def test_open_as_user(self):
        """
        test opening for read, write, read/write (which also tests reading and writing ;)
        """
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        target_file = self.target_file
        for perms in range(12):
            perms = 1 << perms
            target_file.chmod(perms)
            should_fail_read = ((perms & 0o700) >> 6 | (perms & 0o070) >> 3 | (perms & 0o007)) & 4 == 0
            should_fail_write = ((perms & 0o700) >> 6 | (perms & 0o070) >> 3 | (perms & 0o007)) & 2 == 0
            text = '\n%03o\n' % perms
            if should_fail_read:
                for mode in ('r', ):
                    check_exception(IOError(13, 'denied'), open, target_file, mode)
            else:
                for mode in ('r', ) :
                    with open(target_file, mode) as file:
                        file.seek(0)
                        self.assertEqual(file.read(), '0')
            if should_fail_write:
                for mode in ('w', 'a', ):
                    check_exception(IOError(13, 'denied'), open, target_file, mode)
            else:
                for mode in ('w', 'a', ):
                    with open(target_file, mode) as file:
                        file.write(text)
                    target_file.chmod(perms | 4)
                    with open(target_file, 'r') as file:
                        self.assertTrue(text in file.read())
                    target_file.chmod(perms)
            if should_fail_read or should_fail_write:
                for mode in ('r+', 'w+', 'a+'):
                    check_exception(IOError(13, 'denied'), open, target_file, mode)
            else:
                for mode in ('r+', 'w+', 'a+'):
                    with open(target_file, mode) as file:
                        file.seek(0)
                        self.assertEqual(file.read(), '0')
                        file.seek(-1)
                        file.write(text)
                        file.seek(0)
                        self.assertTrue(text in file.read())
            target_file.chmod(perms | 2)
            with open(target_file, 'w') as file:
                file.write('0')

    def test_readdir_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        user_names = [u.pw_name for u in users]
        for user in home.listdir():
            test_user = filter(lambda u: u.pw_name == user, users + users_in_different_group[0:1])[0]
            if user in user_names:
                self.assertEqual(set(home.listdir(user)), set(common_folders[:3] + common_files[:5] + ['FnxFS']))
                self.assertEqual(set(home.listdir(user/'Desktop')), set(['selfie.png', 'logo.jpg']))
                self.assertEqual(set(home.listdir(user/'Public')), set(['letters', 'motto.txt']))
                stat = home.stat(user/'FnxFS')
                self.assertEqual(
                        (stat.st_uid, stat.st_gid, stat.st_mode & 0o777),
                        (test_user.pw_uid, test_user.pw_gid, 0o555),
                        )
                self.assertTrue(remote.listdir())
                self.assertEqual(home.listdir(user/'FnxFS'), ['Public'])
            else:
                self.assertEqual(
                        set(home.listdir(user)),
                        set(common_folders[:3] + common_files[:5]),
                        'mismatch for user %s: %r vs %r' % (user, set(home.listdir(user)), set(common_folders[:3] + common_files[:5])),
                        )
                self.assertEqual(set(home.listdir(user/'Desktop')), set(['selfie.png', 'logo.jpg']))
                self.assertEqual(set(home.listdir(user/'Public')), set(['letters', 'motto.txt']))

    def test_readdir_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        user_names = [u.pw_name for u in users]
        for user in home.listdir():
            test_user = filter(lambda u: u.pw_name == user, users + users_in_different_group[0:1])[0]
            if user in user_names:
                self.assertEqual(set(home.listdir(user)), set(common_folders[:3] + common_files[:5] + ['FnxFS']))
                stat = home.stat(user/'FnxFS')
                self.assertEqual(
                        (stat.st_uid, stat.st_gid, stat.st_mode & 0o777),
                        (test_user.pw_uid, test_user.pw_gid, 0o555),
                        'mismatch for user %s:  .../home/FnxFS --> %r;  should be --> %r' % (
                            user,
                            (stat.st_uid, stat.st_gid, stat.st_mode & 0o777),
                            (test_user.pw_uid, test_user.pw_gid, 0o555),
                            ),
                        )
                self.assertEqual(set(home.listdir(user/'Desktop')), set(['selfie.png', 'logo.jpg']))
                self.assertEqual(set(home.listdir(user/'Public')), set(['letters', 'motto.txt']))
                if test_user is actual_user:
                    found = home.listdir(user/'FnxFS')
                    self.assertEqual(
                            found,
                            ['Public'],
                            'mismatch for user %s: %r vs %r' % (user, home.listdir(user/'FnxFS'), ['Public']),
                            )
                else:
                    check_exception(OSError(13, 'denied'), home.listdir, user/'FnxFS')
            else:
                self.assertEqual(
                        set(home.listdir(user)),
                        set(common_folders[:3] + common_files[:5]),
                        'mismatch for user %s: %r vs %r' % (user, set(home.listdir(user)), set(common_folders[:3] + common_files[:5])),
                        )
                self.assertEqual(set(home.listdir(user/'Desktop')), set(['selfie.png', 'logo.jpg']))
                self.assertEqual(set(home.listdir(user/'Public')), set(['letters', 'motto.txt']))

    def test_rename_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = (local/user.pw_name/common_files[0]).path/'boring_new_name'
            before = target_file.path.listdir()
            self.assertTrue(target_file.filename in before)
            target_file.rename(target_file.path/'boring_new_name')
            after = target_file.path.listdir()
            self.assertTrue(target_file.filename not in after)
            self.assertTrue(local_file.exists())

    def test_rename_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = (local/user.pw_name/common_files[0]).path/'boring_new_name'
            if user is actual_user:
                before = target_file.path.listdir()
                self.assertTrue(target_file.filename in before)
                target_file.rename(target_file.path/'boring_new_name')
                after = target_file.path.listdir()
                self.assertTrue(target_file.filename not in after)
                self.assertTrue(local_file.exists())
            else:
                before = target_file.path.listdir()
                self.assertTrue(target_file.filename in before)
                check_exception(OSError(13, 'denied'), target_file.rename, target_file.path/'boring_new_name')
                after = target_file.path.listdir()
                self.assertTrue(target_file.filename in after)
                self.assertFalse(local_file.exists())

    def test_rmdir_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target_subdir = home/user.pw_name/common_folders[0]
            local_subdir = local/user.pw_name/common_folders[0]
            before = target_subdir.path.listdir()
            self.assertTrue(target_subdir.filename in before)
            target_subdir.rmdir()
            after = target_subdir.path.listdir()
            self.assertTrue(target_subdir.filename not in after)
            self.assertFalse(target_subdir.exists())
            self.assertFalse(local_subdir.exists())

    def test_rmdir_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target_subdir = home/user.pw_name/common_folders[0]
            local_subdir = local/user.pw_name/common_folders[0]
            if user is actual_user:
                before = target_subdir.path.listdir()
                self.assertTrue(target_subdir.filename in before)
                target_subdir.rmdir()
                after = target_subdir.path.listdir()
                self.assertTrue(target_subdir.filename not in after)
                self.assertFalse(target_subdir.exists())
                self.assertFalse(local_subdir.exists())
            else:
                before = target_subdir.path.listdir()
                self.assertTrue(target_subdir.filename in before)
                check_exception(OSError(13, 'denied'), target_subdir.rmdir)
                after = target_subdir.path.listdir()
                self.assertTrue(target_subdir.filename in after)
                self.assertTrue(local_subdir.exists())

    def test_symlink_creation_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target = home/user.pw_name/common_folders[1]/'nothing_to_see_here.txt'
            source = Path('/usr/local/share/imaginary_friend')
            source.symlink(target)
            self.assertTrue(target.lexists())
            stat = target.lstat()
            self.assertTrue((stat.st_uid, stat.st_gid), (0, 0))

    def test_symlink_creation_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target = home/user.pw_name/common_folders[1]/'nothing_to_see_here.txt'
            source = Path('/usr/local/share/imaginary_friend')
            if user is actual_user:
                source.symlink(target)
                self.assertTrue(target.lexists())
                stat = target.lstat()
                self.assertTrue((stat.st_uid, stat.st_gid), (actual_user_id, actual_user.pw_gid))
            else:
                check_exception(OSError(13, 'denied'), source.symlink, target)

    def test_truncate_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        target_file = self.target_file
        local_file = self.local_file
        for perms in range(12):
            # initialize the file
            target_file.chmod(2)
            with open(target_file, 'w') as file:
                file.write('0123456789')
            self.assertEqual(target_file.stat().st_size, 10)
            self.assertEqual(local_file.stat().st_size, 10)
            # calculate and set permissions
            perms = 1 << perms
            target_file.chmod(perms)
            for i in range(10, -1, -1):
                with open(target_file, 'r+') as file:
                    file.seek(i)
                    file.truncate()
                self.assertEqual(target_file.stat().st_size, i)
                self.assertEqual(local_file.stat().st_size, i)

    def test_truncate_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        target_file = self.target_file
        local_file = self.local_file
        for perms in range(12):
            # initialize the file
            target_file.chmod(2)
            with open(target_file, 'w') as file:
                file.write('0123456789')
            self.assertEqual(target_file.stat().st_size, 10)
            self.assertEqual(local_file.stat().st_size, 10)
            # calculate and set permissions
            perms = 1 << perms
            target_file.chmod(perms)
            should_succeed = ((perms & 0o700) >> 6 | (perms & 0o070) >> 3 | (perms & 0o007)) & 6 == 6
            if should_succeed:
                for i in range(10, -1, -1):
                    with open(target_file, 'r+') as file:
                        file.seek(i)
                        file.truncate()
                    self.assertEqual(target_file.stat().st_size, i)
                    self.assertEqual(local_file.stat().st_size, i)
            else:
                check_exception(IOError(13, 'denied'), open, target_file, 'r+')

    def test_unlink_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = local/user.pw_name/common_files[0]
            before = target_file.path.listdir()
            self.assertTrue(target_file.filename in before)
            target_file.unlink()
            after = target_file.path.listdir()
            self.assertTrue(target_file.filename not in after)
            self.assertFalse(target_file.exists())
            self.assertFalse(local_file.exists())

    def test_unlink_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = local/user.pw_name/common_files[0]
            if user is actual_user:
                before = target_file.path.listdir()
                self.assertTrue(target_file.filename in before)
                target_file.unlink()
                after = target_file.path.listdir()
                self.assertTrue(target_file.filename not in after)
                self.assertFalse(target_file.exists())
                self.assertFalse(local_file.exists())
            else:
                before = target_file.path.listdir()
                self.assertTrue(target_file.filename in before)
                check_exception(OSError(13, 'denied'), target_file.unlink)
                after = target_file.path.listdir()
                self.assertTrue(target_file.filename in after)
                self.assertTrue(local_file.exists())

    def test_utimens_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        epoch = DateTime(1970, 1, 1).toordinal()
        now = DateTime.now()
        yesterday1 = now.replace(delta_day=-1)
        yesterday2 = yesterday1.replace(delta_minute=7)

        yesterday = (
                (yesterday1.toordinal() - epoch) * 24*60*60 + yesterday1.hour*3600 + yesterday1.minute*60 + yesterday1.second,
                (yesterday2.toordinal() - epoch) * 24*60*60 + yesterday2.hour*3600 + yesterday2.minute*60 + yesterday2.second,
                )
        tomorrow1 = now.replace(delta_day=1)
        tomorrow2 = tomorrow1.replace(delta_minute=-7)
        tomorrow = (
                (tomorrow1.toordinal() - epoch) * 24*60*60 + tomorrow1.hour*3600 + tomorrow1.minute*60 + tomorrow1.second,
                (tomorrow2.toordinal() - epoch) * 24*60*60 + tomorrow2.hour*3600 + tomorrow2.minute*60 + tomorrow2.second,
                )
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = local/user.pw_name/common_files[0]
            target_file.utime(yesterday)
            stat = target_file.stat()
            self.assertEqual((stat.st_atime, stat.st_mtime), yesterday)
            stat = local_file.stat()
            self.assertEqual((stat.st_atime, stat.st_mtime), yesterday)
            target_file.utime(tomorrow)
            stat = target_file.stat()
            self.assertEqual((stat.st_atime, stat.st_mtime), tomorrow)
            stat = local_file.stat()
            self.assertEqual((stat.st_atime, stat.st_mtime), tomorrow)

    def test_utimens_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        epoch = DateTime(1970, 1, 1).toordinal()
        now = DateTime.now()
        yesterday1 = now.replace(delta_day=-1)
        yesterday2 = yesterday1.replace(delta_minute=7)

        yesterday = (
                (yesterday1.toordinal() - epoch) * 24*60*60 + yesterday1.hour*3600 + yesterday1.minute*60 + yesterday1.second,
                (yesterday2.toordinal() - epoch) * 24*60*60 + yesterday2.hour*3600 + yesterday2.minute*60 + yesterday2.second,
                )
        tomorrow1 = now.replace(delta_day=1)
        tomorrow2 = tomorrow1.replace(delta_minute=-7)
        tomorrow = (
                (tomorrow1.toordinal() - epoch) * 24*60*60 + tomorrow1.hour*3600 + tomorrow1.minute*60 + tomorrow1.second,
                (tomorrow2.toordinal() - epoch) * 24*60*60 + tomorrow2.hour*3600 + tomorrow2.minute*60 + tomorrow2.second,
                )
        for user in users:
            target_file = home/user.pw_name/common_files[0]
            local_file = local/user.pw_name/common_files[0]
            if user is actual_user:
                target_file = home/user.pw_name/common_files[0]
                local_file = local/user.pw_name/common_files[0]
                target_file.utime(yesterday)
                stat = target_file.stat()
                self.assertEqual((stat.st_atime, stat.st_mtime), yesterday)
                stat = local_file.stat()
                self.assertEqual((stat.st_atime, stat.st_mtime), yesterday)
                target_file.utime(tomorrow)
                stat = target_file.stat()
                self.assertEqual((stat.st_atime, stat.st_mtime), tomorrow)
                stat = local_file.stat()
                self.assertEqual((stat.st_atime, stat.st_mtime), tomorrow)
            else:
                check_exception(OSError(13, 'denied'), target_file.utime, yesterday)
                check_exception(OSError(13, 'denied'), target_file.utime, tomorrow)


class TestRemoteFS(TestCase):

    def setUp(self):
        # make sure we're root
        os.setreuid(actual_user_id, 0)
        os.setregid(actual_user.pw_gid, 0)
        self.tearDown()
        # set up local structure
        for user in users:
            local.mkdir(user.pw_name)
        # set up remote structure
        for subdir in (
                'Accounting',
                'Accounting/Acct Rec',
                'Accounting/Acct Pay',
                'Human Resources',
                'Misc',
                'Production',
                'Quality Control',
                'Quality Control/Accounting',
                'Quality Control/Human Resources',
                'Quality Control/Production',
                'Quality Control/Sales',
                'Sales',
                ):
            remote.mkdir(subdir)
        user1, user2 = users_in_same_group[:2]
        with perm_file.open('w') as perms:
            perms.write(
                    '%(user1)s,%(user2)s\n'
                    'all:none:Accounting/*\n'
                    'all:none:Accounting/Acct Rec/*\n'
                    'all:read:Accounting/Acct Rec/*\n'
                    'all:none:Accounting/Acct Pay/*\n'
                    'all:read:Accounting/Acct Pay/*\n'
                    'all:none:Human Resources/*\n'
                    '%(user2)s:read:Human Resources/*\n'
                    'all:none:Misc/*\n'
                    '%(user1)s:write:Misc/*\n'
                    'all:none:Production/*\n'
                    'all:none:Quality Control/*\n'
                    '%(user2)s:write:Quality Control/*\n'
                    '%(user1)s:create:Quality Control/*\n'
                    'all:none:Sales/*\n'
                    'all:none:Accounting/invisible.txt\n'
                    'all:none:Accounting/visible.txt\n'
                    '%(user1)s:read:Accounting/visible.txt\n'
                    '%(user2)s:write:Accounting/visible.txt\n'
                    'all:none:Accounting/Acct Rec/debts.osv\n'
                    'all:read:Accounting/Acct Rec/debts.osv\n'
                    'all:none:Accounting/Acct Pay/instruct.txt\n'
                    '%(user2)s:write:Accounting/Acct Pay/instruct.txt\n'
                    # '%(user1)s:write:Misc/daily_stats.pdf\n'
                    % dict(user1=user1.pw_name, user2=user2.pw_name)
                    )
        for rf in remote_files:
            with remote.open(rf, 'w') as file:
                file.write(rf)
        self.target_file = 'FnxFS/Accounting/visible.txt'
        self.user1 = {
                '':
                        ('Accounting', 'Misc', 'Quality Control'),
                'Accounting':
                        ('Acct Pay', 'Acct Rec', 'visible.txt'),
                'Accounting/Acct Pay':
                        (),
                'Accounting/Acct Rec':
                        ('debts.osv', ),
                'Misc':
                        ('daily_stats.pdf', ),
                'Quality Control':
                        ('Accounting', 'Human Resources', 'Production', 'Sales'),
                'Quality Control/Accounting':
                        (),
                'Quality Control/Human Resources':
                        (),
                'Quality Control/Production':
                        (),
                'Quality Control/Sales':
                        (),
                }
        self.user2 = {
                '':
                        ('Accounting', 'Human Resources', 'Quality Control'),
                'Accounting':
                        ('Acct Pay', 'Acct Rec', 'visible.txt'),
                'Accounting/Acct Pay':
                        ('instruct.txt',),
                'Accounting/Acct Rec':
                        ('debts.osv', ),
                'Human Resources':
                        (),
                'Quality Control':
                        ('Accounting', 'Human Resources', 'Production', 'Sales'),
                'Quality Control/Accounting':
                        (),
                'Quality Control/Human Resources':
                        (),
                'Quality Control/Production':
                        (),
                'Quality Control/Sales':
                        (),
                }


    def tearDown(self):
        # make sure we're root
        os.setreuid(actual_user_id, 0) 
        for subdir in remote.listdir():
            remote.rmtree(subdir)
        for subdir in local.listdir():
            local.rmtree(subdir)

    @skipIf(not_suid, 'test should be run as a normal user')
    def test_access_as_root(self):
        """
        can test for file existence, or read|write|execute, but is based on the real user
        """
        # check as root, which should only fail if X_OK is asked for, but the execution bit is
        # not set for any of user/group/other
        os.setreuid(0, actual_user_id)
        os.setregid(0, actual_user.pw_gid)
        target_folder = home/actual_user.pw_name/'FnxFS'
        for perm in range(8):
            for file, mode in (
                    ('Accounting/invisible.txt', None),
                    ('Accounting/visible.txt', 0o400),
                    ('Accounting/Acct Rec/debts.osv', 0o400),
                    ('Accounting/Acct Pay/instruct.txt', None),
                    ('Misc/daily_stats.pdf', 0o600),
                    ):
                if mode is None:
                    self.assertFalse(target_folder.access(file, perm))
                else:
                    success = mode >> 6 & perm == perm
                    self.assertEqual(
                            target_folder.access(file, perm), success,
                            'file: %s  request: %o  mode: %o  result: %s' % (target_folder/file, perm, mode, not success),
                            )
        os.setreuid(actual_user_id, 0)

    @skipIf(not_suid, 'test should be run as a normal user')
    def test_access_as_user(self):
        """
        can test for file existence, or read|write|execute, but is based on the real user
        """
        user1, user2 = users[:2]
        target1 = home/user1.pw_name/'FnxFS'
        target2 = home/user2.pw_name/'FnxFS'
        for perm in range(8):
            for file, mode in (
                    ('Accounting/invisible.txt', None),
                    ('Accounting/visible.txt', 0o400),
                    ('Accounting/Acct Rec/debts.osv', 0o400),
                    ('Accounting/Acct Pay/instruct.txt', None),
                    ('Misc/daily_stats.pdf', 0o600),
                    ):
                if mode is None:
                    self.assertFalse(target1.access(file, perm))
                else:
                    success = mode >> 6 & perm == perm
                    self.assertEqual(target1.access(file, perm), success)
                self.assertFalse(target2.access(file, perm))

    def test_chmod_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        target_file = home/actual_user.pw_name/self.target_file
        mode = target_file.stat().st_mode
        for perms, _ in all_perms(suid=True):
            if mode == perms:
                target_file.chmod(perms)
            else:
                check_exception(OSError(13, 'denied'), target_file.chmod, perms)

    def test_chmod_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target_file = home/user.pw_name/self.target_file
            if user is actual_user:
                mode = target_file.stat().st_mode
            for perms, _ in all_perms(suid=True):
                if user.pw_uid == actual_user_id and mode == perms:
                    target_file.chmod(perms)
                    self.assertEqual(target_file.stat().st_mode & 0o7777, perms)
                else:
                    check_exception(OSError(13, 'denied'), target_file.chmod, perms)

    def test_chown_group(self):
        """
        owner cannot be changed
        """
        # update users
        for user in users:
            (home/user.pw_name/'FnxFS').listdir()
        # lose root privilege
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        uncommon_gid = different_groups[0].gr_gid
        common_gid = common_groups[-1].gr_gid
        for user in users:
            target_file = home/user.pw_name/self.target_file
            if user is actual_user:
                self.assertTrue(target_file.exists())
                target_file.chown(user.pw_uid, user.pw_gid)
            check_exception(OSError(13, 'denied'), target_file.chown, user.pw_uid, uncommon_gid)
            check_exception(OSError(13, 'denied'), target_file.chown, user.pw_uid, common_gid)
        # grab root privilege back
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target_file = home/user.pw_name/self.target_file
            self.assertTrue(target_file.exists())
            check_exception(OSError(13, 'denied'), target_file.chown, 0, 0)
            target_file.chown(user.pw_uid, user.pw_gid)

    def test_chown_user(self):
        """
        owner cannot be changed
        """
        # lose root privilege
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        target_file = home/actual_user.pw_name/self.target_file
        for user in users:
            if user is actual_user:
                target_file.chown(user.pw_uid, user.pw_gid)
            else:
                check_exception(OSError(13, 'denied'), target_file.chown, user.pw_uid, user.pw_gid)
        # grab root privilege back
        os.seteuid(0)
        for user in users:
            check_exception(OSError(13, 'denied'), target_file.chown, 0, 0)

    def test_create_hidden_as_root(self):
        # hidden and swap files can always be created, except in the FnxFS root
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            # create a file the normal way
            FnxFS = home/user.pw_name/'FnxFS'
            check_exception(IOError(13, 'denied'), FnxFS.open, '.failure', 'w')
            check_exception(IOError(13, 'denied'), FnxFS.open, '.~lock.failure', 'w')
            readable = FnxFS/'Accounting/Acct Rec'
            readable.open('.success', 'w').close()
            readable.remove('.success')
            readable.open('.~lock.success', 'w').close()
            stat = readable.stat('.~lock.success')
            self.assertEqual((stat.st_uid, stat.st_gid), (user.pw_uid, user.pw_gid))
            self.assertEqual(
                    stat.st_mode & 0o777,
                    0o600,
                    'permissions should be 0o600, but got %03o -- umask set correctly?' % stat.st_mode,
                    )
            readable.remove('.~lock.success')
        target_file = readable/'.~lock.success'
        for perms, _ in all_perms(suid=True):
            # create a file and specify the permissions
            fd = os.open(target_file, os.O_RDWR|os.O_CREAT, perms)
            os.close(fd)
            self.assertTrue(target_file.exists())
            stat = target_file.stat()
            self.assertEqual((stat.st_uid, stat.st_gid), (user.pw_uid, user.pw_gid))
            target_file.remove()

    def test_create_normal_as_root(self):
        # otherwise, only directories whose user has write authority can have files created in them
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            # create a file the normal way
            FnxFS = home/user.pw_name/'FnxFS'
            readable = FnxFS/'Accounting/Acct Rec'
            # writable is only writable for actual_user
            writable = FnxFS/'Quality Control'
            # now some tests
            check_exception(IOError(13, 'denied'), FnxFS.open, 'failure', 'w')
            check_exception(IOError(13, 'denied'), readable.open, 'failure', 'w')
            if user is not actual_user:
                check_exception(IOError(13, 'denied'), writable.open, 'failure', 'w')
            else:
                writable.open('success', 'w').close()
                stat = writable.stat('success')
                self.assertEqual((stat.st_uid, stat.st_gid), (user.pw_uid, user.pw_gid))
                self.assertEqual(
                        stat.st_mode & 0o777,
                        0o600,
                        'permissions should be 0o600, but got %03o -- umask set correctly?' % stat.st_mode,
                        )
                writable.remove('success')
        target_file = home/actual_user.pw_name/'FnxFS/Quality Control/success'
        for perms, _ in all_perms(suid=True):
            # create a file and specify the permissions
            fd = os.open(target_file, os.O_RDWR|os.O_CREAT, perms)
            os.close(fd)
            self.assertTrue(target_file.exists())
            stat = target_file.stat()
            self.assertEqual((stat.st_uid, stat.st_gid), (actual_user.pw_uid, actual_user.pw_gid))
            target_file.remove()

    def test_create_hidden_as_user(self):
        # hidden and swap files can always be created, except in the FnxFS root
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            # create a file the normal way
            FnxFS = home/user.pw_name/'FnxFS'
            readable = FnxFS/'Accounting/Acct Rec'
            check_exception(IOError(13, 'denied'), FnxFS.open, '.failure', 'w')
            check_exception(IOError(13, 'denied'), FnxFS.open, '.~lock.failure', 'w')
            if user is not actual_user:
                check_exception(IOError(13, 'denied'), readable.open, '.success', 'w')
            else:
                readable.open('.success', 'w').close()
                readable.remove('.success')
                readable.open('.~lock.success', 'w').close()
                stat = readable.stat('.~lock.success')
                self.assertEqual((stat.st_uid, stat.st_gid), (user.pw_uid, user.pw_gid))
                self.assertEqual(
                        stat.st_mode & 0o777,
                        0o600,
                        'permissions should be 0o600, but got %03o -- umask set correctly?' % stat.st_mode,
                        )
                readable.remove('.~lock.success')
        target_file = home/actual_user.pw_name/'FnxFS/Accounting/Acct Rec/.~lock.success'
        for perms, _ in all_perms(suid=True):
            # create a file and specify the permissions
            fd = os.open(target_file, os.O_RDWR|os.O_CREAT, perms)
            os.close(fd)
            self.assertTrue(target_file.exists())
            stat = target_file.stat()
            self.assertEqual((stat.st_uid, stat.st_gid), (actual_user.pw_uid, actual_user.pw_gid))
            target_file.remove()

    def test_create_normal_as_user(self):
        # otherwise, only directories whose user has write authority can have files created in them
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            # create a file the normal way
            FnxFS = home/user.pw_name/'FnxFS'
            readable = FnxFS/'Accounting/Acct Rec'
            # writable is only writable for actual_user
            writable = FnxFS/'Quality Control'
            # now some tests
            check_exception(IOError(13, 'denied'), FnxFS.open, 'failure', 'w')
            check_exception(IOError(13, 'denied'), readable.open, 'failure', 'w')
            if user is not actual_user:
                check_exception(IOError(13, 'denied'), writable.open, 'failure', 'w')
            else:
                writable.open('success', 'w').close()
                stat = writable.stat('success')
                self.assertEqual((stat.st_uid, stat.st_gid), (user.pw_uid, user.pw_gid))
                self.assertEqual(
                        stat.st_mode & 0o777,
                        0o600,
                        'permissions should be 0o600, but got %03o -- umask set correctly?' % stat.st_mode,
                        )
                writable.remove('success')
        target_file = home/actual_user.pw_name/'FnxFS/Quality Control/success'
        for perms, _ in all_perms(suid=True):
            # create a file and specify the permissions
            fd = os.open(target_file, os.O_RDWR|os.O_CREAT, perms)
            os.close(fd)
            self.assertTrue(target_file.exists())
            stat = target_file.stat()
            self.assertEqual((stat.st_uid, stat.st_gid), (actual_user.pw_uid, actual_user.pw_gid))
            target_file.remove()

    def test_link_as_root(self):
        # hard links not allowed
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            local_source = home/user.pw_name/'sample.txt'
            with open(local_source, 'w') as f:
                f.write('abcdefghijklmnopqrstuvwxyz')
            if user is actual_user:
                remote_source = home/user.pw_name/'FnxFS/Quality Control/sample.txt'
                with remote_source.open('w') as f:
                    f.write('zywvutsrqponmlkjihgfedcba')
            for link_user in users:
                new_name = remote_source.path/'alphabet.txt'
                check_exception(OSError(95, 'no support'), local_source.link, new_name)
                if link_user is user is actual_user:
                    check_exception(OSError(95, 'no support'), remote_source.link, new_name)

    def test_link_as_user(self):
        # hard links not allowed
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            local_source = home/user.pw_name/'sample.txt'
            with open(local_source, 'w') as f:
                f.write('abcdefghijklmnopqrstuvwxyz')
            if user is actual_user:
                remote_source = home/user.pw_name/'FnxFS/Quality Control/sample.txt'
                with remote_source.open('w') as f:
                    f.write('zywvutsrqponmlkjihgfedcba')
            for link_user in users:
                new_name = remote_source.path/'alphabet.txt'
                check_exception(OSError(95, 'no support'), local_source.link, new_name)
                if link_user is user is actual_user:
                    check_exception(OSError(95, 'no support'), remote_source.link, new_name)

    def test_mkdir_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            test = home/user.pw_name/'FnxFS/Quality Control/test'
            for perms, _ in all_perms():
                if user is not actual_user:
                    check_exception(OSError(13, 'denied'), test.mkdir, mode=perms)
                else:
                    test.mkdir(mode=perms)
                    stat = test.stat()
                    self.assertEqual(stat.st_mode & 0o7777, 0o700, 'mismatch -- expected: 0o700, got: %06o' % stat.st_mode)
                    test.rmdir()

    def test_mkdir_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            test = home/user.pw_name/'FnxFS/Quality Control/test'
            for perms, _ in all_perms():
                if user is not actual_user:
                    check_exception(OSError(13, 'denied'), test.mkdir, mode=perms)
                else:
                    test.mkdir(mode=perms)
                    stat = test.stat()
                    self.assertEqual(stat.st_mode & 0o7777, 0o700, 'mismatch -- expected: 0o700, got: %06o' % stat.st_mode)
                    test.rmdir()

    def test_open_as_root(self):
        """
        test opening for read, write, read/write (which also tests reading and writing ;)
        """
        os.seteuid(0)
        os.setegid(0)
        for user in users[:2]:
            hidden_file_name = home/user.pw_name/'FnxFS/Accounting/.hidden'
            with hidden_file_name.open('w') as hidden:
                hidden.write('Accounting/.hidden')
            if user is actual_user:
                visible_file_name = home/user.pw_name/'FnxFS/Misc/daily_stats.pdf'
            else:
                visible_file_name = home/user.pw_name/'FnxFS/Accounting/visible.txt'
            for mode in ('r', 'r+', 'a+'):
                with open(hidden_file_name, mode) as file:
                    file.seek(0)
                    hidden_data = file.read()
                    self.assertTrue(hidden_data in hidden_file_name)
                with open(visible_file_name, mode) as file:
                    file.seek(0)
                    visible_data = file.read()
                    self.assertTrue(visible_data in visible_file_name)
                test_text = '\n%s\n' % user.pw_name
                for mode in ('w', 'r+', 'w+', 'a+'):
                    with open(hidden_file_name, mode) as file:
                        file.write(test_text)
                    with open(hidden_file_name, 'r') as file:
                        self.assertTrue(test_text in file.read())
                    with open(hidden_file_name, 'w') as file:
                        file.write(hidden_data)
                for mode in ('w', 'r+', 'w+', 'a+'):
                    with open(visible_file_name, mode) as file:
                        file.write(test_text)
                    with open(visible_file_name, 'r') as file:
                        self.assertTrue(test_text in file.read())
                    with open(visible_file_name, 'w') as file:
                        file.write(visible_data)

    def test_open_as_user(self):
        """
        test opening for read, write, read/write (which also tests reading and writing ;)
        """
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users[:2]:
            hidden_file_name = home/user.pw_name/'FnxFS/Accounting/.hidden'
            if user is actual_user:
                with hidden_file_name.open('w') as hidden:
                    hidden.write('Accounting/.hidden')
                visible_file_name = home/user.pw_name/'FnxFS/Misc/daily_stats.pdf'
            else:
                visible_file_name = home/user.pw_name/'FnxFS/Accounting/visible.txt'
            for mode in ('r', 'r+', 'a+'):
                if user is not actual_user:
                    check_exception(IOError(13, 'denied'), hidden_file_name.open, mode)
                    check_exception(IOError(13, 'denied'), visible_file_name.open, mode)
                else:
                    with open(hidden_file_name, mode) as file:
                        file.seek(0)
                        hidden_data = file.read()
                        self.assertTrue(hidden_data in hidden_file_name)
                    with open(visible_file_name, mode) as file:
                        file.seek(0)
                        visible_data = file.read()
                        self.assertTrue(visible_data in visible_file_name)
                    test_text = '\n%s\n' % user.pw_name
                    for mode in ('w', 'r+', 'w+', 'a+'):
                        with open(hidden_file_name, mode) as file:
                            file.write(test_text)
                        with open(hidden_file_name, 'r') as file:
                            self.assertTrue(test_text in file.read())
                        with open(hidden_file_name, 'w') as file:
                            file.write(hidden_data)
                    for mode in ('w', 'r+', 'w+', 'a+'):
                        with open(visible_file_name, mode) as file:
                            file.write(test_text)
                        with open(visible_file_name, 'r') as file:
                            self.assertTrue(test_text in file.read())
                        with open(visible_file_name, 'w') as file:
                            file.write(visible_data)

    def test_readdir_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        user1_folder = home/users[0].pw_name/'FnxFS/'
        user2_folder = home/users[1].pw_name/'FnxFS/'
        for path, dirs, files in user1_folder.walk():
            path -= user1_folder
            entries = set(dirs + files)
            expected = set(self.user1[path])
            self.assertEqual(
                    entries, expected,
                    'mismatch for user %s:\n%r\n  vs\n%r' % (users[0].pw_name, entries, expected),
                    )
        for path, dirs, files in user2_folder.walk():
            path -= user2_folder
            entries = set(dirs + files)
            expected = set(self.user2[path])
            self.assertEqual(
                    entries, expected,
                    'mismatch for user %s:\n%r\n  vs\n%r' % (users[0].pw_name, entries, expected),
                    )

    def test_readdir_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        user1_folder = home/users[0].pw_name/'FnxFS/'
        user2_folder = home/users[1].pw_name/'FnxFS/'
        for path, dirs, files in user1_folder.walk():
            path -= user1_folder
            entries = set(dirs + files)
            expected = set(self.user1[path])
            self.assertEqual(
                    entries, expected,
                    'mismatch for user %s:\n%r\n  vs\n%r' % (users[0].pw_name, entries, expected),
                    )
        check_exception(StopIteration, next, user2_folder.walk())

    def test_rename_as_root(self):
        # only some renames allowed:
        #   hidden to hidden
        #   hidden to writable normal
        # on create-delete enabled shares, all renaming is allowed
        #
        # user1: (r) Accounting/visible.txt
        #        (w) Misc/daily_stats.pdf
        #        (c) Quality Control/*
        # user2: (r) Accounting/Acct Rec/debts.osv
        #        (w) Accounting/Acct Pay/instruct.txt
        os.seteuid(0)
        os.setegid(0)
        user1 = home/users[0].pw_name/'FnxFS'
        user2 = home/users[1].pw_name/'FnxFS'
        user1_readable = user1/'Accounting/visible.txt'
        user1_writable = user1/'Misc/daily_stats.pdf'
        user1_creatable = user1/'Quality Control'
        user2_readable = user2/'Accounting/Acct Rec/debts.osv'
        user2_writable = user2/'Accounting/Acct Pay/instruct.txt'
        # user1 tests
        hidden1 = user1_readable.path/'.hidden_file_1'
        hidden2 = user1_readable.path/'.hidden_file_2'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        with hidden2.open('w') as file:
            file.write('hidden file 2')
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 2')
        with user1_readable.open() as file:
            self.assertEqual(file.read(), 'Accounting/visible.txt')
        hidden1.rename(hidden2)
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        self.assertFalse(hidden1.exists())
        check_exception(OSError(13, 'denied'), hidden2.rename, user1_readable)
        with user1_writable.open() as file:
            self.assertEqual(file.read(), 'Misc/daily_stats.pdf')
        hidden2.rename(user1_writable)
        with user1_writable.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        self.assertFalse(hidden2.exists())
        c1 = user1_creatable/'test_qc.ods'
        c2 = user1_creatable/'final_qc.ods'
        with c1.open('w') as file:
            file.write('testing... testing... 1 2 3....')
        with c1.open() as file:
            self.assertEqual(file.read(), 'testing... testing... 1 2 3....')
        c1.rename(c2)
        check_exception(OSError(13, 'denied'), c2.rename, user1_readable)
        check_exception(OSError(13, 'denied'), user1_readable.rename, c2)
        check_exception(OSError(13, 'denied'), user1_readable.rename, user1_writable)
        check_exception(OSError(13, 'denied'), user1_writable.rename, user1_readable)
        # user2 tests
        hidden1 = user2_readable.path/'.hidden_file_1'
        hidden2 = user2_readable.path/'.hidden_file_2'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        with hidden2.open('w') as file:
            file.write('hidden file 2')
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 2')
        with user2_readable.open() as file:
            self.assertEqual(file.read(), 'Accounting/Acct Rec/debts.osv')
        hidden1.rename(hidden2)
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        self.assertFalse(hidden1.exists())
        check_exception(OSError(13, 'denied'), hidden2.rename, user2_readable)
        with user2_writable.open() as file:
            self.assertEqual(file.read(), 'Accounting/Acct Pay/instruct.txt')
        hidden2.rename(user2_writable)
        with user2_writable.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        self.assertFalse(hidden2.exists())

    def test_rename_as_user(self):
        os.seteuid(0)
        os.setegid(0)
        user1 = home/users[0].pw_name/'FnxFS'
        user2 = home/users[1].pw_name/'FnxFS'
        user2_readable = user2/'Accounting/Acct Rec/debts.osv'
        user2_writable = user2/'Accounting/Acct Pay/instruct.txt'
        hidden1 = user2_readable.path/'.hidden_file_1'
        hidden2 = user2_readable.path/'.hidden_file_2'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        with hidden2.open('w') as file:
            file.write('hidden file 2')
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 2')
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        # all actions against another user's FnxFS directory should fail
        check_exception(OSError(13, 'denied'), hidden1.rename, hidden2)
        check_exception(OSError(13, 'denied'), hidden1.rename, user2_readable)
        check_exception(OSError(13, 'denied'), hidden1.rename, user2_writable)
        check_exception(OSError(13, 'denied'), user2_readable.rename, hidden2)
        check_exception(OSError(13, 'denied'), user2_readable.rename, user2_writable)
        check_exception(OSError(13, 'denied'), user2_writable.rename, user2_readable)
        # test our own FnxFS directory
        user1_readable = user1/'Accounting/visible.txt'
        user1_writable = user1/'Misc/daily_stats.pdf'
        user1_creatable = user1/'Quality Control'
        hidden1 = user1_readable.path/'.hidden_file_1'
        hidden2 = user1_readable.path/'.hidden_file_2'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        with hidden2.open('w') as file:
            file.write('hidden file 2')
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 2')
        with user1_readable.open() as file:
            self.assertEqual(file.read(), 'Accounting/visible.txt')
        hidden1.rename(hidden2)
        with hidden2.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        self.assertFalse(hidden1.exists())
        check_exception(OSError(13, 'denied'), hidden2.rename, user1_readable)
        with user1_writable.open() as file:
            self.assertEqual(file.read(), 'Misc/daily_stats.pdf')
        hidden2.rename(user1_writable)
        with user1_writable.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        self.assertFalse(hidden2.exists())
        c1 = user1_creatable/'test_qc.ods'
        c2 = user1_creatable/'final_qc.ods'
        with c1.open('w') as file:
            file.write('testing... testing... 1 2 3....')
        with c1.open() as file:
            self.assertEqual(file.read(), 'testing... testing... 1 2 3....')
        c1.rename(c2)
        check_exception(OSError(13, 'denied'), c2.rename, user1_readable)
        check_exception(OSError(13, 'denied'), user1_readable.rename, c2)
        check_exception(OSError(13, 'denied'), user1_readable.rename, user1_writable)
        check_exception(OSError(13, 'denied'), user1_writable.rename, user1_readable)

    def test_rmdir_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            FnxFS = home/user.pw_name/'FnxFS'
            for path, dirs, files in FnxFS.walk():
                for subdir in dirs:
                    if user != actual_user or not path.endswith('/Quality Control'):
                        check_exception(OSError(13, 'denied'), path.rmdir, subdir)
                    else:
                        path.rmdir(subdir)
                        path.mkdir(subdir)

    def test_rmdir_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            FnxFS = home/user.pw_name/'FnxFS'
            for path, dirs, files in FnxFS.walk():
                for subdir in dirs:
                    if user != actual_user or not path.endswith('/Quality Control'):
                        check_exception(OSError(13, 'denied'), path.rmdir, subdir)
                    else:
                        path.rmdir(subdir)
                        path.mkdir(subdir)

    def test_symlink_creation_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        for user in users:
            target = home/user.pw_name/'FnxFS/Quality Control/nothing_to_see_here.txt'
            source = Path('/usr/local/share/imaginary_friend')
            check_exception(OSError(95, 'no support'), source.symlink, target)

    def test_symlink_creation_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        for user in users:
            target = home/user.pw_name/'FnxFS/Quality Control/nothing_to_see_here.txt'
            source = Path('/usr/local/share/imaginary_friend')
            if user is actual_user:
                check_exception(OSError(95, 'no support'), source.symlink, target)
            else:
                check_exception(OSError(13, 'denied'), source.symlink, target)

    def test_truncate_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        # user 1
        bad_target = home/users[0].pw_name/'FnxFS/Accounting/visible.txt'
        check_exception(IOError(13, 'denied'), bad_target.open, 'r+')
        good_target = home/users[0].pw_name/'FnxFS/Misc/daily_stats.pdf'
        with open(good_target, 'w') as file:
            file.write('0123456789')
        self.assertEqual(good_target.stat().st_size, 10)
        for i in range(10, -1, -1):
            with open(good_target, 'r+') as file:
                file.seek(i)
                file.truncate()
            self.assertEqual(good_target.stat().st_size, i)
        # user 2
        bad_target = home/users[1].pw_name/'FnxFS/Accounting/Acct Rec/debts.osv'
        check_exception(IOError(13, 'denied'), bad_target.open, 'r+')
        good_target = home/users[1].pw_name/'FnxFS/Accounting/Acct Pay/instruct.txt'
        with open(good_target, 'w') as file:
            file.write('0123456789')
        self.assertEqual(good_target.stat().st_size, 10)
        for i in range(10, -1, -1):
            with open(good_target, 'r+') as file:
                file.seek(i)
                file.truncate()
            self.assertEqual(good_target.stat().st_size, i)

    def test_truncate_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        # user 1
        bad_target = home/users[0].pw_name/'FnxFS/Accounting/visible.txt'
        check_exception(IOError(13, 'denied'), bad_target.open, 'r+')
        good_target = home/users[0].pw_name/'FnxFS/Misc/daily_stats.pdf'
        with open(good_target, 'w') as file:
            file.write('0123456789')
        self.assertEqual(good_target.stat().st_size, 10)
        for i in range(10, -1, -1):
            with open(good_target, 'r+') as file:
                file.seek(i)
                file.truncate()
            self.assertEqual(good_target.stat().st_size, i)
        # user 1 trying to access user 2
        bad_target = home/users[1].pw_name/'FnxFS/Accounting/Acct Rec/debts.osv'
        check_exception(IOError(13, 'denied'), bad_target.open, 'r+')
        bad_target = home/users[1].pw_name/'FnxFS/Accounting/Acct Pay/instruct.txt'
        check_exception(IOError(13, 'denied'), bad_target.open, 'w')

    def test_unlink_as_root(self):
        # on readable shares, only hidden files can be removed
        # on create-delete enabled shares, all removing is allowed
        #
        # user1: (r) Accounting/visible.txt
        #        (w) Misc/daily_stats.pdf
        #        (c) Quality Control/*
        # user2: (r) Accounting/Acct Rec/debts.osv
        #        (w) Accounting/Acct Pay/instruct.txt
        os.seteuid(0)
        os.setegid(0)
        user1 = home/users[0].pw_name/'FnxFS'
        user2 = home/users[1].pw_name/'FnxFS'
        user1_readable = user1/'Accounting/visible.txt'
        user1_writable = user1/'Misc/daily_stats.pdf'
        user1_creatable = user1/'Quality Control'
        user2_readable = user2/'Accounting/Acct Rec/debts.osv'
        user2_writable = user2/'Accounting/Acct Pay/instruct.txt'
        # user1 tests
        hidden1 = user1_readable.path/'.hidden_file_1'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        hidden1.unlink()
        self.assertFalse(hidden1.exists())
        check_exception(OSError(13, 'denied'), user1_writable.unlink)
        c1 = user1_creatable/'test_qc.ods'
        with c1.open('w') as file:
            file.write('testing... testing... 1 2 3....')
        with c1.open() as file:
            self.assertEqual(file.read(), 'testing... testing... 1 2 3....')
        c1.unlink()
        self.assertFalse(c1.exists())
        # user2 tests
        hidden1 = user2_readable.path/'.hidden_file_1'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        hidden1.unlink()
        self.assertFalse(hidden1.exists())
        with user2_writable.open() as file:
            self.assertEqual(file.read(), 'Accounting/Acct Pay/instruct.txt')
        check_exception(OSError(13, 'denied'), user2_writable.unlink)

    def test_unlink_as_user(self):
        # on readable shares, only hidden files can be removed
        # on create-delete enabled shares, all removing is allowed
        #
        # user1: (r) Accounting/visible.txt
        #        (w) Misc/daily_stats.pdf
        #        (c) Quality Control/*
        # user2: (r) Accounting/Acct Rec/debts.osv
        #        (w) Accounting/Acct Pay/instruct.txt
        user1 = home/users[0].pw_name/'FnxFS'
        user2 = home/users[1].pw_name/'FnxFS'
        user1_readable = user1/'Accounting/visible.txt'
        user1_writable = user1/'Misc/daily_stats.pdf'
        user1_creatable = user1/'Quality Control'
        user2_readable = user2/'Accounting/Acct Rec/debts.osv'
        user2_writable = user2/'Accounting/Acct Pay/instruct.txt'
        # user2 setup
        hidden1 = user2_readable.path/'.hidden_file_1'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        hidden1.unlink()
        self.assertFalse(hidden1.exists())
        with user2_writable.open() as file:
            self.assertEqual(file.read(), 'Accounting/Acct Pay/instruct.txt')
        # lose privilege
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        # user 2 tests
        check_exception(OSError(13, 'denied'), hidden1.unlink)
        check_exception(OSError(13, 'denied'), user2_writable.unlink)
        # user1 tests
        hidden1 = user1_readable.path/'.hidden_file_1'
        with hidden1.open('w') as file:
            file.write('hidden file 1')
        with hidden1.open() as file:
            self.assertEqual(file.read(), 'hidden file 1')
        hidden1.unlink()
        self.assertFalse(hidden1.exists())
        check_exception(OSError(13, 'denied'), user1_writable.unlink)
        c1 = user1_creatable/'test_qc.ods'
        with c1.open('w') as file:
            file.write('testing... testing... 1 2 3....')
        with c1.open() as file:
            self.assertEqual(file.read(), 'testing... testing... 1 2 3....')
        c1.unlink()
        self.assertFalse(c1.exists())

    def test_utimens_as_root(self):
        os.seteuid(0)
        os.setegid(0)
        epoch = DateTime(1970, 1, 1).toordinal()
        now = DateTime.now()
        yesterday1 = now.replace(delta_day=-1)
        yesterday2 = yesterday1.replace(delta_minute=7)
        yesterday = (
                (yesterday1.toordinal() - epoch) * 24*60*60 + yesterday1.hour*3600 + yesterday1.minute*60 + yesterday1.second,
                (yesterday2.toordinal() - epoch) * 24*60*60 + yesterday2.hour*3600 + yesterday2.minute*60 + yesterday2.second,
                )
        tomorrow1 = now.replace(delta_day=1)
        tomorrow2 = tomorrow1.replace(delta_minute=-7)
        tomorrow = (
                (tomorrow1.toordinal() - epoch) * 24*60*60 + tomorrow1.hour*3600 + tomorrow1.minute*60 + tomorrow1.second,
                (tomorrow2.toordinal() - epoch) * 24*60*60 + tomorrow2.hour*3600 + tomorrow2.minute*60 + tomorrow2.second,
                )
        for user in users:
            FnxFS = home/user.pw_name/'FnxFS'
            for path, dirs, files in FnxFS.walk():
                entries = dirs + files
                for target in entries:
                    if user != actual_user or not path.endswith('/Quality Control'):
                        check_exception(OSError(13, 'denied'), path.utime, target, yesterday)
                        check_exception(OSError(13, 'denied'), path.utime, target, tomorrow)
                    else:
                        if target in dirs:
                            target_file = path/target/'test_file.txt'
                            target_file.open('w').close()
                        else:
                            target_file = path/target
                        target_file.utime(yesterday)
                        stat = target_file.stat()
                        self.assertEqual((stat.st_atime, stat.st_mtime), yesterday)
                        target_file.utime(tomorrow)
                        stat = target_file.stat()
                        self.assertEqual((stat.st_atime, stat.st_mtime), tomorrow)
                        if target_file.filename == 'test_file.txt':
                            target_file.unlink()

    def test_utimens_as_user(self):
        os.seteuid(actual_user_id)
        os.setegid(actual_user.pw_gid)
        epoch = DateTime(1970, 1, 1).toordinal()
        now = DateTime.now()
        yesterday1 = now.replace(delta_day=-1)
        yesterday2 = yesterday1.replace(delta_minute=7)
        yesterday = (
                (yesterday1.toordinal() - epoch) * 24*60*60 + yesterday1.hour*3600 + yesterday1.minute*60 + yesterday1.second,
                (yesterday2.toordinal() - epoch) * 24*60*60 + yesterday2.hour*3600 + yesterday2.minute*60 + yesterday2.second,
                )
        tomorrow1 = now.replace(delta_day=1)
        tomorrow2 = tomorrow1.replace(delta_minute=-7)
        tomorrow = (
                (tomorrow1.toordinal() - epoch) * 24*60*60 + tomorrow1.hour*3600 + tomorrow1.minute*60 + tomorrow1.second,
                (tomorrow2.toordinal() - epoch) * 24*60*60 + tomorrow2.hour*3600 + tomorrow2.minute*60 + tomorrow2.second,
                )
        for user in users:
            FnxFS = home/user.pw_name/'FnxFS'
            for path, dirs, files in FnxFS.walk():
                entries = dirs + files
                for target in entries:
                    if user != actual_user or not path.endswith('/Quality Control'):
                        check_exception(OSError(13, 'denied'), path.utime, target, yesterday)
                        check_exception(OSError(13, 'denied'), path.utime, target, tomorrow)
                    else:
                        if target in dirs:
                            target_file = path/target/'test_file.txt'
                            target_file.open('w').close()
                        else:
                            target_file = path/target
                        target_file.utime(yesterday)
                        stat = target_file.stat()
                        self.assertEqual((stat.st_atime, stat.st_mtime), yesterday)
                        target_file.utime(tomorrow)
                        stat = target_file.stat()
                        self.assertEqual((stat.st_atime, stat.st_mtime), tomorrow)
                        if target_file.filename == 'test_file.txt':
                            target_file.unlink()

    def test_hidden_files_show_in_listdir(self):
        # hidden files should show up only if the user has at least read permmission for a folder
        user1_no_read = home/users[0].pw_name/'FnxFS/Accounting'
        user2_no_read = home/users[1].pw_name/'FnxFS/Accounting'
        hidden = user1_no_read/'.hidden'
        user1_start = set(user1_no_read.listdir())
        user2_start = set(user2_no_read.listdir())
        hidden.open('w').close()
        user1_stop = set(user1_no_read.listdir())
        user2_stop = set(user2_no_read.listdir())
        self.assertEqual(user1_start ^ user1_stop, set())
        self.assertEqual(user2_start ^ user2_stop, set())
        hidden.remove()
        user1_read = home/users[0].pw_name/'FnxFS/Accounting/Acct Rec'
        user2_read = home/users[1].pw_name/'FnxFS/Accounting/Acct Rec'
        hidden = user1_read/'.hidden'
        user1_start = set(user1_read.listdir())
        user2_start = set(user2_read.listdir())
        hidden.open('w').close()
        user1_stop = set(user1_read.listdir())
        user2_stop = set(user2_read.listdir())
        self.assertEqual(user1_start ^ user1_stop, set(['.hidden']))
        self.assertEqual(user2_start ^ user2_stop, set(['.hidden']))
        hidden.remove()
        user1_read = home/users[0].pw_name/'FnxFS/Quality Control/Sales'
        user2_read = home/users[1].pw_name/'FnxFS/Quality Control/Sales'
        hidden = user1_read/'.hidden'
        user1_start = set(user1_read.listdir())
        user2_start = set(user2_read.listdir())
        hidden.open('w').close()
        user1_stop = set(user1_read.listdir())
        user2_stop = set(user2_read.listdir())
        self.assertEqual(user1_start ^ user1_stop, set(['.hidden']))
        self.assertEqual(user2_start ^ user2_stop, set(['.hidden']))
        hidden.remove()

    # def test_share_names_do_not_start_with_period(self):
    #     raise Exception('not implemented')

    # def test_second_user_is_updated_from_permissions(self):
    #     raise Exception('not implemented')

    # def test_remove_open_file(self):
    #     raise Exception('not implemented')

    # def test_folder_read_permission_carries_towards_root(self):
    #     raise Exception('not implemented')

    # def test_fuse_hidden_files(self):
    #     raise Exception('not implemented')


#######################
# Supporting functions
#######################

def all_perms(suid=False):
    for user in range(8):
        x = False
        if user & 1:
            x = True
        user <<= 6
        for group in range(8):
            if group & 1:
                x = True
            group <<= 3
            for other in range(8):
                if other & 1:
                    x = True
                perms = user | group | other
                yield perms, x
                if suid:
                    for i in [0o1000, 0o2000, 0o4000]:
                        yield i | perms, x

def check_exception(exception, callable, *args, **kwds):
    exc_type = type(exception)
    if exc_type is type:
        exc_type = exception
        errno = None
    else:
        errno = exception.errno
    try:
        exc_name = exc_type.__name__
    except AttributeError:
        exc_name = str(exc_type)
    try:
        callable(*args, **kwds)
    except exc_type, exc:
        if errno is None or exc.errno == errno:
            return
        raise AssertionError('%s raised, but with %r' % (exc_name, exc.args))
    except:
        exc = sys.exc_info()[1]
        try:
            raised_name = exc.__class__.__name__
        except AttributeError:
            raised_name = str(exc)
        raise AssertionError("%s expected, but %s%r raised" % (exc_name, raised_name, exc.args))
    else:
        raise AssertionError("no exception raised")

def create_dirs():
    log_file = Path('/var/log/fnxfsd.log')
    if log_file.exists():
        log_file.remove()
    home.mkdir()
    local.mkdir()
    remote.mkdir()
    open(perm_file, 'w').close()
    open(shares_file, 'w').close()
    test = os.open(test_conf, os.O_WRONLY|os.O_CREAT|os.O_EXCL, 0o440)
    test = os.fdopen(test, 'w')
    test.write(
            'server_user = "root"\n'
            'server_pass = "%(password)s"\n'
            'root = "%(password)s"\n'
            'openerp = "127.0.0.1"'
            % {'password':root_password}
            )
    test.close()
    with open(perm_file, 'w') as perms:
        perms.write('%s,%s\n' % (users[0].pw_name, users[1].pw_name))
        perms.write('all:read:Public/*\n')
    remote.mkdir('Public')
    command = [
            daemon, local, home, '-o', 'rw',
            '--config', test_conf,
            '--remote_root', remote,
            '--shares_file', shares_file,
            '--pid_file', Path.getcwd()/'fnxfsd.pid',
            '--testing', 
            ]
    if generate_log:
        command.append('--verbose')
    subprocess.call(' '.join(command), shell=True)
    time.sleep(2)
    if 'FnxFS' not in check_output(['df']):
        raise SystemExit('unable to mount daemon')

def get_common_groups(l1, l2):
    """
    return a list of groups present in both l1 and l2
    """
    # group entries are not hashable, thus we cannot use them with sets
    g1 = [g.gr_gid for g in l1]
    g2 = [g.gr_gid for g in l2]
    common = set(g1) & set(g2)
    return [g for g in l1 if g.gr_gid in common]

def get_groups_with_user(user):
    # user is a pwd pwentry
    return filter(lambda g: user.pw_name in g.gr_mem, system_groups)

def get_test_users():
    """select users to be used in testing

    users must have ids > 1000, and have at least one group in common
    returns actual_user, actual_user_id, test_users
    """
    global actual_user_id, actual_user, common_groups, different_groups, users_in_same_group, users_in_different_group, users
    actual_user_id = os.getuid()
    actual_user = filter(lambda p: p.pw_uid == actual_user_id, system_users)[0]
    users_in_same_group = [actual_user]
    users_in_different_group = []
    same_groups = filter(lambda g: actual_user.pw_name in g.gr_mem, system_groups)
    common_groups = same_groups[:]
    different_groups = filter(lambda g: actual_user.pw_name not in g.gr_mem and g.gr_gid != 0, system_groups)
    for user in system_users:
        if user.pw_uid < 1000:
            if any(user.pw_name in g.gr_mem for g in same_groups):
                continue
            users_in_different_group.append(user)
        elif any(user.pw_name in g.gr_mem and user not in users_in_same_group for g in common_groups):
            users_in_same_group.append(user)
            new_common_groups = reduce(
                    get_common_groups,
                    [get_groups_with_user(user) for user in users_in_same_group],
                    )
            if not new_common_groups:
                users_in_same_group.pop()
            else:
                common_groups = new_common_groups
    users = users_in_same_group[:3]

def remove_dirs():
    # return
    os.setuid(0)
    subprocess.call('fusermount -u "%s"' % home, shell=True)
    time.sleep(2)
    for folder in (home, local, remote):
        if folder.exists():
            folder.rmtree()
    for file in (perm_file, shares_file, test_conf, Path('fnxfsd.pid')):
        if file.exists():
            file.remove()
    

if __name__ == '__main__':
    Run()
