#!/usr/local/bin/python

from __future__ import print_function

import pandaemonium

from dbf import DateTime
from pandaemonium import PidLockFile
from path import Path
from scription import Command, REQUIRED, FLAG, OPTION, Run
import errno
import sys
import time


fs_root = Path('/var/openerp/fnx_fs')
archive_root = Path('/var/openerp/fnx_fs_archive')


@Command(
        src=('file to copy', REQUIRED, 's', Path),
        dst=('where to put it (and possibly new name', REQUIRED, 'd', Path),
        timeout=('how long to wait for lock', OPTION, 't', int),
        )
def cp(
        src,
        dst,
        timeout=10,
        ):
    """
    copy file into FnxFS structure, also archiving it
    """
    if not dst.exists():
        raise SystemExit('destination file does not exist')
    archive_dst = archive_root / (dst - fs_root)
    if not archive_dst.exists():
        archive_dst.mkdirs()
    with PidLockFile(archive_dst/'locked.pid', time_out=timeout):
        src.copy(dst)
        if archive_needed(dst):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)


@Command(
        src=('file to archive', REQUIRED, 'f', Path),
        )
def archive(src):
    """
    copy existing FnxFS file into the archive
    """
    if not src.exists():
        raise SystemExit('source file does not exist')
    if archive_needed(src):
        archive_dst = archive_root / (src - fs_root)
        if not archive_dst.exists():
            archive_dst.mkdirs()
        with PidLockFile(archive_dst/'locked.pid'):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)

    
def next_archive_name(archive_path):
    """
    archive_path is the folder holding the archive copies

    if the source file is

      /fs_root/Production/Q_ALL.ods

    then the archive path and file name will be

      /archive_root/Production/Q_ALL.ods/[time_stamp]

    if a file already exists with the current time stamp, sleep for one second and grab
    the next one
    """
    while True:
        time_stamp = DateTime.now().strftime('%Y-%m-%d_%H:%M:%S')
        archive_name = archive_path/time_stamp
        if archive_name.exists():
            time.sleep(1)
        else:
            return archive_name

def archive_needed(src):
    """
    return True if the metadata on src differs from the latest archive version's
    """
    # use st_size, st_atime, st_mtime
    archive = archive_root / (src - fs_root)
    try:
        arc = sorted(archive.listdir())[-1]
    except OSError:
        exc = sys.exc_info()[1]
        if exc.errno != errno.ENOENT:
            raise
        return True
    src_meta = src.stat()[6:9]
    try:
        arc_meta = arc.stat()[6:9]
    except OSError:
        exc = sys.exc_info()[1]
        if exc.errno != errno.ENOENT:
            raise
        return True
    return src_meta != arc_meta


if __name__ == "__main__":
    Run()
