#!/usr/local/bin/python

from __future__ import print_function

import pandaemonium

from dbf import DateTime
from pandaemonium import PidLockFile
from path import Path
from scription import Command, REQUIRED, FLAG, OPTION, Run
from VSS.time_machine import PropertyDict
import errno
import openerplib
import sys
import time


fs_root = Path('/var/openerp/fnxfs')
archive_root = Path('/var/openerp/fnxfs_archive')
OE = PropertyDict()

execfile('/etc/openerp/credentials')


@Command(
        src=('file to archive', REQUIRED, 'f', Path),
        )
def archive(src):
    """
    copy existing FnxFS file into the archive
    """
    if not src.exists():
        raise SystemExit('source file does not exist')
    if archive_needed(src):
        archive_dst = archive_root / (src - fs_root)
        if not archive_dst.exists():
            archive_dst.mkdirs()
        with PidLockFile(archive_dst/'locked.pid'):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)


@Command(
        )
def clean_slate():
    """
    Removes all files entries from OpenERP, leaves folders in place but removes permissions.
    Does not touch files on disk.
    """
    connect_oe(host, db, user, pw)
    file_ids = OE.fs_file.search([(1,'=',1)])
    OE.fs_file.unlink(file_ids, context={'keep_files':True})


@Command(
        src=('file to copy', REQUIRED, 's', Path),
        dst=('where to put it (and possibly new name', REQUIRED, 'd', Path),
        timeout=('how long to wait for lock', OPTION, 't', int),
        )
def cp(
        src,
        dst,
        timeout=10,
        ):
    """
    copy file into FnxFS structure, also archiving it
    """
    if not dst.exists():
        raise SystemExit('destination file does not exist')
    archive_dst = archive_root / (dst - fs_root)
    if not archive_dst.exists():
        archive_dst.mkdirs()
    with PidLockFile(archive_dst/'locked.pid', time_out=timeout):
        src.copy(dst)
        if archive_needed(dst):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)

@Command(
        )
def user_shares():
    """
    Add users, files, and folders found in UserShares.
    """
    folder_names = {
            'qcmanagement': 'Quality Control',
            'qc_scratch':   'Quality Control/Scratch',
            'r-and-d':      'Research & Development',
            'marketing':    'Marketing',
            'DropEmployeeHeadshotsHere':    'Human Resources/Headshots',
            'hr':           'Human Resources',
            '121Shared':    'To Be Renamed',
            }




def next_archive_name(archive_path):
    """
    archive_path is the folder holding the archive copies

    if the source file is

      /fs_root/Production/Q_ALL.ods

    then the archive path and file name will be

      /archive_root/Production/Q_ALL.ods/[time_stamp]

    if a file already exists with the current time stamp, sleep for one second and grab
    the next one
    """
    while True:
        time_stamp = DateTime.now().strftime('%Y-%m-%d_%H:%M:%S')
        archive_name = archive_path/time_stamp
        if archive_name.exists():
            time.sleep(1)
        else:
            return archive_name

def archive_needed(src):
    """
    return True if the metadata on src differs from the latest archive version's
    """
    # use st_size, st_atime, st_mtime
    archive = archive_root / (src - fs_root)
    try:
        arc = sorted(archive.listdir())[-1]
    except OSError:
        exc = sys.exc_info()[1]
        if exc.errno != errno.ENOENT:
            raise
        return True
    src_meta = src.stat()[6:9]
    try:
        arc_meta = arc.stat()[6:9]
    except OSError:
        exc = sys.exc_info()[1]
        if exc.errno != errno.ENOENT:
            raise
        return True
    return src_meta != arc_meta

def connect_oe(hostname, database, user, password):
    OE.conn = conn = openerplib.get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.fs_file = conn.get_model('fnx.fs.file')
    OE.fs_folder = conn.get_model('fnx.fs.folder')


if __name__ == "__main__":
    Run()
