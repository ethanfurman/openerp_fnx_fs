#!/usr/local/bin/suid-python

from __future__ import print_function

import pandaemonium

from collections import defaultdict
from dbf import DateTime
from getpass import getpass
from pandaemonium import PidLockFile
from path import Path
from scription import Command, REQUIRED, FLAG, OPTION, Run, Execute
from VSS.time_machine import PropertyDict
import errno
import openerplib
import pwd
import sys
import time


fs_root = Path('/var/openerp/fnxfs')
archive_root = Path('/var/openerp/fnxfs_archive')
fnx_mount = Path('/etc/openerp/fnxfs.mount')
fnx_mount_pids = Path('/var/run/%s.pid')
OE = PropertyDict()
openerp_ids = tuple(pwd.getpwnam('openerp')[2:4])

sshfs_option = [
        '-o allow_other',
        '-o kernel_cache',
        '-o StrictHostKeyChecking=no',
        '-o reconnect',
        '-o compression=no',
        '-o cache_timeout=600',
        '-o ServerAliveInterval=15',
        '-o ServerAliveCountMax=4',
        '-o workaround=rename',
        ]

execfile('/etc/openerp/credentials')
execfile('/etc/openerp/fnxfs_credentials')


@Command(
        src=('file to archive', REQUIRED, 'f', Path),
        )
def archive(src):
    """
    copy existing FnxFS file into the archive
    """
    if not src.exists():
        raise SystemExit('source file does not exist')
    if archive_needed(src):
        archive_dst = archive_root / (src - fs_root)
        if not archive_dst.exists():
            archive_dst.mkdirs(owner=openerp_ids)
        with PidLockFile(archive_dst/'locked.pid'):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)
            src.chown(*openerp_ids)


@Command(
        )
def clean_slate():
    """
    Removes all files entries from OpenERP, leaves folders in place but removes permissions.
    Does not touch files on disk.
    """
    connect_oe(host, db, user, pw)
    file_ids = OE.fs_file.search([(1,'=',1)])
    OE.fs_file.unlink(file_ids, context={'keep_files':True})


@Command(
        src=('file to copy', REQUIRED, 's', Path),
        dst=('where to put it (and possibly new name', REQUIRED, 'd', Path),
        timeout=('how long to wait for lock', OPTION, 't', int),
        force=('make copy even if no record of file exists in OpenERP', FLAG),
        )
def cp(
        src,
        dst,
        timeout=10,
        force=False
        ):
    """
    copy file/folder into FnxFS structure, also archiving it
    """
    if not src.isdir():
        if not dst.exists() and not force:
            raise SystemExit('destination file does not exist (use --force to copy anyway)')
        _cp(src, dst, timeout)
    else:
        for dirpath, dirnames, filenames in src.walk():
            for fn in filenames:
                fn_lower = fn.filename.lower()
                if (
                        '\\' in fn_lower or
                        'touch' in fn_lower or
                        fn_lower.startswith('backup') and fn_lower.endswith('.log') or
                        fn_lower == 'thumbs.db'
                    ):
                    continue
                new_fn = fn.filename
                if new_fn.startswith('.'):
                    if new_fn[1] in '0123456789':
                        new_fn = '0' + new_fn
                    else:
                        continue
                new_fn = new_fn.replace('%20', ' ')
                new_fn = ''.join([ch for ch in new_fn if ord(ch) < 128])
                new_fn = fn.path / new_fn
                _cp(dirpath/fn, dst/dirpath/new_fn, timeout)


def _cp(src, dst, timeout):
    archive_dst = archive_root / (dst - fs_root)
    if not archive_dst.exists():
        archive_dst.mkdirs(owner=openerp_ids)
    if not dst.exists():
        dst.mkdirs(owner=openerp_ids)
    with PidLockFile(archive_dst/'locked.pid', time_out=timeout):
        src.copy(dst)
        dst.chown(*openerp_ids)
        if archive_needed(dst):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)
            archive_dst.chown(*openerp_ids)

@Command(
        folder=('Specific folder to copy (default is all)', OPTION),
        )
def copy_usershares(folder):
    """
    Add files and folders found in UserShares.
    """
    #
    # For each share we care about:
    # 1. mount share in /mnt/11-145
    # 2. for each folder there:
    #    a) create an entry in FnxFS/Folders
    #    b) copy permissions from parent folder
    #    c) create folder in /var/openerp/fnxfs/[parent dirs...]
    # 3. for each file there:
    #    d) create on entry in FnxFs/Files
    #    e) use permissions from containing folder
    #    f) touch file in parent directory
    #    g) use 'cp' command to copy and archive
    # 4. unmount share
    #
    # Notes:
    #    ignore symbolic links
    #    ignore directories with '\' in the name
    #    ignore files named 'touch'
    #    ignore files named backup*.log
    #    ignore hidden files
    #    ignore Thumbs.db (any case)
    #    strip spaces from names (e.g. ' CoAFormat013112')
    #    convert %20 to space
    #    convert files starting with .75 to 0.75
    #    drop characters outside ASCII range
    #
    folder_names = {
            'qcmanagement': 'Quality Control',
            'qc_scratch':   'Quality Control/Scratch',
            'r-and-d':      'Research & Development',
            'marketing':    'Marketing',
            #'DropEmployeeHeadshotsHere':    'Human Resources/Headshots',
            'hr':           'Human Resources',
            #'121Shared':    'To Be Renamed',
            }
    password = getpass('password for remote mounts')
    server_template = '//192.168.11.145/%s'
    mount_template = Path('/var/openerp/11-145-%s')
    for src, dst in folder_names.items():
        server = server_template % src
        mount = mount_template % src
        command = ['mount', '-t cifs', '-o ro', server, mount]
        if not mount.exists():
            mount.mkdir()
        result = Execute(command, password=password)

@Command(
        subcommand=('start | stop | restart shares from a client machine', ),
        machine=('ip address of shares to work with', ),
        )
def sshfs(subcommand='start', machine='all'):
    if subcommand != 'start':
        raise SystemExit('%s not yet implemented' % subcommand)
    if machine != 'all':
        raise SystemExit('only "all" is currently supported')
    start_sshfs(machine, parse_mount_file())


def start_sshfs(machine, mapping):
    """
    start an sshfs for each share per machine

    machine --> ip address or 'all'
    mapping --> mapping of ip address to share, mount
    """
    for ip, shares in mapping:
        if machine in ('all', ip):
            for share, mount in shares:
                command = ['sshfs'] + sshfs_options + ['root@%s:%s' % (ip, share), mount]
                Execute(command, password=server_root)


def parse_mount_file():
    shares = defaultdict(set)
    with open(fnxfs_mount) as data:
        mounts = data.readlines()
    for line in mounts:
        line = line.strip()
        if not line:
            continue
        mount_point, options, source = line.split('\t')
        if options != 'ssh':
            continue
        ip, share_point = source.split(':', 1)
        shares[ip].add((share_point, mount_point)
    return shares

def next_archive_name(archive_path):
    """
    archive_path is the folder holding the archive copies

    if the source file is

      /fs_root/Production/Q_ALL.ods

    then the archive path and file name will be

      /archive_root/Production/Q_ALL.ods/[time_stamp]

    if a file already exists with the current time stamp, sleep for one second and grab
    the next one
    """
    while True:
        time_stamp = DateTime.now().strftime('%Y-%m-%d_%H:%M:%S')
        archive_name = archive_path/time_stamp
        if archive_name.exists():
            time.sleep(1)
        else:
            return archive_name

def archive_needed(src):
    """
    return True if the metadata on src differs from the latest archive version's
    """
    # use st_size, st_atime, st_mtime
    archive = archive_root / (src - fs_root)
    try:
        arc = sorted(archive.glob('/*'))[-1]
    except IndexError:
        return True
    src_meta = src.stat()[6:9]
    arc_meta = arc.stat()[6:9]
    return src_meta != arc_meta

def connect_oe(hostname, database, user, password):
    OE.conn = conn = openerplib.get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.fs_file = conn.get_model('fnx.fs.file')
    OE.fs_folder = conn.get_model('fnx.fs.folder')


if __name__ == "__main__":
    Run()
