#!/usr/local/bin/python

from __future__ import print_function

import pandaemonium

from dbf import DateTime
from getpass import getpass
from pandaemonium import PidLockFile
from path import Path
from scription import Command, REQUIRED, FLAG, OPTION, Run
from VSS.time_machine import PropertyDict
import errno
import openerplib
import sys
import time


fs_root = Path('/var/openerp/fnxfs')
archive_root = Path('/var/openerp/fnxfs_archive')
OE = PropertyDict()

execfile('/etc/openerp/credentials')


@Command(
        src=('file to archive', REQUIRED, 'f', Path),
        )
def archive(src):
    """
    copy existing FnxFS file into the archive
    """
    if not src.exists():
        raise SystemExit('source file does not exist')
    if archive_needed(src):
        archive_dst = archive_root / (src - fs_root)
        if not archive_dst.exists():
            archive_dst.mkdirs()
        with PidLockFile(archive_dst/'locked.pid'):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)


@Command(
        )
def clean_slate():
    """
    Removes all files entries from OpenERP, leaves folders in place but removes permissions.
    Does not touch files on disk.
    """
    connect_oe(host, db, user, pw)
    file_ids = OE.fs_file.search([(1,'=',1)])
    OE.fs_file.unlink(file_ids, context={'keep_files':True})


@Command(
        src=('file to copy', REQUIRED, 's', Path),
        dst=('where to put it (and possibly new name', REQUIRED, 'd', Path),
        timeout=('how long to wait for lock', OPTION, 't', int),
        force=('make copy even if no record of file exists in OpenERP', FLAG),
        )
def cp(
        src,
        dst,
        timeout=10,
        force=False
        ):
    """
    copy file into FnxFS structure, also archiving it
    """
    if not dst.exists() and not force:
        raise SystemExit('destination file does not exist (use --force to copy anyway)')
    archive_dst = archive_root / (dst - fs_root)
    if not archive_dst.exists():
        archive_dst.mkdirs()
    with PidLockFile(archive_dst/'locked.pid', time_out=timeout):
        src.copy(dst)
        if archive_needed(dst):
            archive_dst = next_archive_name(archive_dst)
            src.copy(archive_dst)

@Command(
        folder=('Specific folder to copy (default is all)', OPTION),
        )
def copy_usershares(folder):
    """
    Add files and folders found in UserShares.
    """
    #
    # For each share we care about:
    # 1. mount share in /mnt/11-145
    # 2. for each folder there:
    #    a) create an entry in FnxFS/Folders
    #    b) copy permissions from parent folder
    #    c) create folder in /var/openerp/fnxfs/[parent dirs...]
    # 3. for each file there:
    #    d) create on entry in FnxFs/Files
    #    e) use permissions from containing folder
    #    f) touch file in parent directory
    #    g) use 'cp' command to copy and archive
    # 4. unmount share
    #
    # Notes:
    #    ignore symbolic links
    #    ignore directories with '\' in the name
    #    ignore files named 'touch'
    #    ignore files named backup*.log
    #    ignore hidden files
    #    ignore Thumbs.db (any case)
    #    strip spaces from names (e.g. ' CoAFormat013112')
    #    convert %20 to space
    #    convert files starting with .75 to 0.75
    #    drop characters outside ASCII range
    #
    folder_names = {
            'qcmanagement': 'Quality Control',
            'qc_scratch':   'Quality Control/Scratch',
            'r-and-d':      'Research & Development',
            'marketing':    'Marketing',
            #'DropEmployeeHeadshotsHere':    'Human Resources/Headshots',
            'hr':           'Human Resources',
            #'121Shared':    'To Be Renamed',
            }
    password = getpass('password for remote mounts')
    server_template = '//192.168.11.145/%s'
    mount_template = Path('/var/openerp/11-145-%s')
    for src, dst in folder_names.items():
        server = server_template % src
        mount = mount_template % src
        command = ['mount', '-t cifs', '-o ro', server, mount]
        if not mount.exists():
            mount.mkdir()
        result = Execute(command, password=password)
    args, bufsize=-1, cwd=None, password=None
    



def next_archive_name(archive_path):
    """
    archive_path is the folder holding the archive copies

    if the source file is

      /fs_root/Production/Q_ALL.ods

    then the archive path and file name will be

      /archive_root/Production/Q_ALL.ods/[time_stamp]

    if a file already exists with the current time stamp, sleep for one second and grab
    the next one
    """
    while True:
        time_stamp = DateTime.now().strftime('%Y-%m-%d_%H:%M:%S')
        archive_name = archive_path/time_stamp
        if archive_name.exists():
            time.sleep(1)
        else:
            return archive_name

def archive_needed(src):
    """
    return True if the metadata on src differs from the latest archive version's
    """
    # use st_size, st_atime, st_mtime
    archive = archive_root / (src - fs_root)
    try:
        arc = sorted(archive.listdir())[-1]
    except OSError:
        exc = sys.exc_info()[1]
        if exc.errno != errno.ENOENT:
            raise
        return True
    src_meta = src.stat()[6:9]
    try:
        arc_meta = arc.stat()[6:9]
    except OSError:
        exc = sys.exc_info()[1]
        if exc.errno != errno.ENOENT:
            raise
        return True
    return src_meta != arc_meta

def connect_oe(hostname, database, user, password):
    OE.conn = conn = openerplib.get_connection(hostname=hostname, database=database, login=user, password=password)
    OE.fs_file = conn.get_model('fnx.fs.file')
    OE.fs_folder = conn.get_model('fnx.fs.folder')


if __name__ == "__main__":
    Run()
